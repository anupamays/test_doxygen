<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>doxygen_test: spnego._context.ContextProxy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">doxygen_test
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacespnego.html">spnego</a></li><li class="navelem"><a class="el" href="namespacespnego_1_1__context.html">_context</a></li><li class="navelem"><a class="el" href="classspnego_1_1__context_1_1_context_proxy.html">ContextProxy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="classspnego_1_1__context_1_1_context_proxy-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">spnego._context.ContextProxy Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base class for a authentication context.  
 <a href="#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for spnego._context.ContextProxy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classspnego_1_1__context_1_1_context_proxy.png" usemap="#spnego._5Fcontext.ContextProxy_map" alt=""/>
  <map id="spnego._5Fcontext.ContextProxy_map" name="spnego._5Fcontext.ContextProxy_map">
<area href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html" title="CredSSP proxy class CredSSP authentication." alt="spnego._credssp.CredSSPProxy" shape="rect" coords="0,112,205,136"/>
<area href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html" title="GSSAPI proxy class for GSSAPI on Linux." alt="spnego._gss.GSSAPIProxy" shape="rect" coords="215,112,420,136"/>
<area href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html" title="A context wrapper for a Python managed SPNEGO context." alt="spnego._negotiate.NegotiateProxy" shape="rect" coords="430,112,635,136"/>
<area href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html" title="A context wrapper for a Python managed NTLM context." alt="spnego._ntlm.NTLMProxy" shape="rect" coords="645,112,850,136"/>
<area href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html" title="SSPI proxy class for pure SSPI on Windows." alt="spnego._sspi.SSPIProxy" shape="rect" coords="860,112,1065,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac1cef0762f9713239569bd6a72a7e485" id="r_ac1cef0762f9713239569bd6a72a7e485"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1cef0762f9713239569bd6a72a7e485">__init__</a> (self, typing.List[Credential] credentials, typing.Optional[str] hostname, typing.Optional[str] service, typing.Optional[<a class="el" href="classspnego_1_1channel__bindings_1_1_gss_channel_bindings.html">GssChannelBindings</a>] <a class="el" href="#aed0fe31dc278e3ca90571adbfab35738">channel_bindings</a>, <a class="el" href="classspnego_1_1__context_1_1_context_req.html">ContextReq</a> <a class="el" href="#aeaffd504b8f02006532dd611f3c86986">context_req</a>, str <a class="el" href="#a6202a97e29287e5eb8e378b02c59ddfc">usage</a>, str <a class="el" href="#a8d4c501ab00f466a4613b5a086877641">protocol</a>, <a class="el" href="classspnego_1_1exceptions_1_1_negotiate_options.html">NegotiateOptions</a> <a class="el" href="#acd185878b1e6f3971fbc04a030450a1e">options</a>)</td></tr>
<tr class="separator:ac1cef0762f9713239569bd6a72a7e485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0285d1a81f7c7377bed8fff18a48207" id="r_ac0285d1a81f7c7377bed8fff18a48207"><td class="memItemLeft" align="right" valign="top">typing.List[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0285d1a81f7c7377bed8fff18a48207">available_protocols</a> (cls, typing.Optional[<a class="el" href="classspnego_1_1exceptions_1_1_negotiate_options.html">NegotiateOptions</a>] <a class="el" href="#acd185878b1e6f3971fbc04a030450a1e">options</a>=None)</td></tr>
<tr class="memdesc:ac0285d1a81f7c7377bed8fff18a48207"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of protocols that the provider can offer.  <br /></td></tr>
<tr class="separator:ac0285d1a81f7c7377bed8fff18a48207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02013b11bc695163a0ecb5562bc6a8de" id="r_a02013b11bc695163a0ecb5562bc6a8de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02013b11bc695163a0ecb5562bc6a8de">iov_available</a> (cls)</td></tr>
<tr class="memdesc:a02013b11bc695163a0ecb5562bc6a8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the context supports IOV wrapping and unwrapping.  <br /></td></tr>
<tr class="separator:a02013b11bc695163a0ecb5562bc6a8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bb4cfcf1874549610c896328965b0c" id="r_a87bb4cfcf1874549610c896328965b0c"><td class="memItemLeft" align="right" valign="top">&quot;ContextProxy&quot;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87bb4cfcf1874549610c896328965b0c">new_context</a> (self)</td></tr>
<tr class="memdesc:a87bb4cfcf1874549610c896328965b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new security context.  <br /></td></tr>
<tr class="separator:a87bb4cfcf1874549610c896328965b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b3d00e12ed927a44f4a3ab63a139fd" id="r_a23b3d00e12ed927a44f4a3ab63a139fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspnego_1_1__context_1_1_sec_pkg_context_sizes.html">SecPkgContextSizes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23b3d00e12ed927a44f4a3ab63a139fd">query_message_sizes</a> (self)</td></tr>
<tr class="memdesc:a23b3d00e12ed927a44f4a3ab63a139fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the important structure sizes for message functions.  <br /></td></tr>
<tr class="separator:a23b3d00e12ed927a44f4a3ab63a139fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dda293d7d52ac7273887f3d23bb2f9d" id="r_a2dda293d7d52ac7273887f3d23bb2f9d"><td class="memItemLeft" align="right" valign="top">typing.Optional[bytes]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dda293d7d52ac7273887f3d23bb2f9d">step</a> (self, typing.Optional[bytes] in_token=None, *typing.Optional[<a class="el" href="classspnego_1_1channel__bindings_1_1_gss_channel_bindings.html">GssChannelBindings</a>] <a class="el" href="#aed0fe31dc278e3ca90571adbfab35738">channel_bindings</a>=None)</td></tr>
<tr class="memdesc:a2dda293d7d52ac7273887f3d23bb2f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a negotiation step.  <br /></td></tr>
<tr class="separator:a2dda293d7d52ac7273887f3d23bb2f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75488cc82ea1e23a105ca6bf3c3f4512" id="r_a75488cc82ea1e23a105ca6bf3c3f4512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspnego_1_1__context_1_1_wrap_result.html">WrapResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75488cc82ea1e23a105ca6bf3c3f4512">wrap</a> (self, bytes data, bool encrypt=True, typing.Optional[int] qop=None)</td></tr>
<tr class="memdesc:a75488cc82ea1e23a105ca6bf3c3f4512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a message, optionally with encryption.  <br /></td></tr>
<tr class="separator:a75488cc82ea1e23a105ca6bf3c3f4512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd4bce65af1dbca62ceb3460457ad62" id="r_aedd4bce65af1dbca62ceb3460457ad62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspnego_1_1__context_1_1_i_o_v_wrap_result.html">IOVWrapResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedd4bce65af1dbca62ceb3460457ad62">wrap_iov</a> (self, typing.Iterable[<a class="el" href="namespacespnego_1_1__context.html#a62693a779f0b7b7b550735696ecab364">IOV</a>] iov, bool encrypt=True, typing.Optional[int] qop=None)</td></tr>
<tr class="memdesc:aedd4bce65af1dbca62ceb3460457ad62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap/Encrypt an IOV buffer.  <br /></td></tr>
<tr class="separator:aedd4bce65af1dbca62ceb3460457ad62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9e37d5346f5bdfc06faacc6dd29985" id="r_a9c9e37d5346f5bdfc06faacc6dd29985"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspnego_1_1__context_1_1_win_r_m_wrap_result.html">WinRMWrapResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c9e37d5346f5bdfc06faacc6dd29985">wrap_winrm</a> (self, bytes data)</td></tr>
<tr class="memdesc:a9c9e37d5346f5bdfc06faacc6dd29985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap/Encrypt data for use with WinRM.  <br /></td></tr>
<tr class="separator:a9c9e37d5346f5bdfc06faacc6dd29985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59cc177e9f4a93a49454afb861fa3c1" id="r_ab59cc177e9f4a93a49454afb861fa3c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspnego_1_1__context_1_1_unwrap_result.html">UnwrapResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab59cc177e9f4a93a49454afb861fa3c1">unwrap</a> (self, bytes data)</td></tr>
<tr class="memdesc:ab59cc177e9f4a93a49454afb861fa3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwrap a message.  <br /></td></tr>
<tr class="separator:ab59cc177e9f4a93a49454afb861fa3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc132845d3d714c4580bfa5aa137ee7c" id="r_abc132845d3d714c4580bfa5aa137ee7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspnego_1_1__context_1_1_i_o_v_unwrap_result.html">IOVUnwrapResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc132845d3d714c4580bfa5aa137ee7c">unwrap_iov</a> (self, typing.Iterable[<a class="el" href="namespacespnego_1_1__context.html#a62693a779f0b7b7b550735696ecab364">IOV</a>] iov)</td></tr>
<tr class="memdesc:abc132845d3d714c4580bfa5aa137ee7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwrap/Decrypt an IOV buffer.  <br /></td></tr>
<tr class="separator:abc132845d3d714c4580bfa5aa137ee7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924f37dc044d78c0b604bea12522ed01" id="r_a924f37dc044d78c0b604bea12522ed01"><td class="memItemLeft" align="right" valign="top">bytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a924f37dc044d78c0b604bea12522ed01">unwrap_winrm</a> (self, bytes header, bytes data)</td></tr>
<tr class="memdesc:a924f37dc044d78c0b604bea12522ed01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwrap/Decrypt a WinRM message.  <br /></td></tr>
<tr class="separator:a924f37dc044d78c0b604bea12522ed01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e90e76c0bf92293d65c6c2d6da3507d" id="r_a3e90e76c0bf92293d65c6c2d6da3507d"><td class="memItemLeft" align="right" valign="top">bytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e90e76c0bf92293d65c6c2d6da3507d">sign</a> (self, bytes data, typing.Optional[int] qop=None)</td></tr>
<tr class="memdesc:a3e90e76c0bf92293d65c6c2d6da3507d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a signature/MIC for a message.  <br /></td></tr>
<tr class="separator:a3e90e76c0bf92293d65c6c2d6da3507d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cd2d0fe2a4fd5d458723e1bdf5c5f8" id="r_a27cd2d0fe2a4fd5d458723e1bdf5c5f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27cd2d0fe2a4fd5d458723e1bdf5c5f8">verify</a> (self, bytes data, bytes mic)</td></tr>
<tr class="memdesc:a27cd2d0fe2a4fd5d458723e1bdf5c5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the signature/MIC for a message.  <br /></td></tr>
<tr class="separator:a27cd2d0fe2a4fd5d458723e1bdf5c5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed04bf7aa25e4060d3ffd9f2e5d440f8" id="r_aed04bf7aa25e4060d3ffd9f2e5d440f8"><td class="memItemLeft" align="right" valign="top">typing.Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed04bf7aa25e4060d3ffd9f2e5d440f8">get_extra_info</a> (self, str name, typing.Any default=None)</td></tr>
<tr class="memdesc:aed04bf7aa25e4060d3ffd9f2e5d440f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return information about the security context.  <br /></td></tr>
<tr class="separator:aed04bf7aa25e4060d3ffd9f2e5d440f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6202a97e29287e5eb8e378b02c59ddfc" id="r_a6202a97e29287e5eb8e378b02c59ddfc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6202a97e29287e5eb8e378b02c59ddfc">usage</a></td></tr>
<tr class="memdesc:a6202a97e29287e5eb8e378b02c59ddfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The usage of the context, <code>initiate</code> for a client and <code>accept</code> for a server.  <br /></td></tr>
<tr class="separator:a6202a97e29287e5eb8e378b02c59ddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4c501ab00f466a4613b5a086877641" id="r_a8d4c501ab00f466a4613b5a086877641"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d4c501ab00f466a4613b5a086877641">protocol</a></td></tr>
<tr class="memdesc:a8d4c501ab00f466a4613b5a086877641"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protocol to set the context up with; <code>ntlm</code>, <code>kerberos</code>, or <code>negotiate</code>.  <br /></td></tr>
<tr class="separator:a8d4c501ab00f466a4613b5a086877641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23d81f74241011b397ab00cecbd9801" id="r_ae23d81f74241011b397ab00cecbd9801"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae23d81f74241011b397ab00cecbd9801">spn</a></td></tr>
<tr class="memdesc:ae23d81f74241011b397ab00cecbd9801"><td class="mdescLeft">&#160;</td><td class="mdescRight">The service principal name of the service to connect to.  <br /></td></tr>
<tr class="separator:ae23d81f74241011b397ab00cecbd9801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0fe31dc278e3ca90571adbfab35738" id="r_aed0fe31dc278e3ca90571adbfab35738"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed0fe31dc278e3ca90571adbfab35738">channel_bindings</a></td></tr>
<tr class="memdesc:aed0fe31dc278e3ca90571adbfab35738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional channel bindings to provide with the.  <br /></td></tr>
<tr class="separator:aed0fe31dc278e3ca90571adbfab35738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd185878b1e6f3971fbc04a030450a1e" id="r_acd185878b1e6f3971fbc04a030450a1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd185878b1e6f3971fbc04a030450a1e">options</a></td></tr>
<tr class="memdesc:acd185878b1e6f3971fbc04a030450a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user specified negotiation options.  <br /></td></tr>
<tr class="separator:acd185878b1e6f3971fbc04a030450a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaffd504b8f02006532dd611f3c86986" id="r_aeaffd504b8f02006532dd611f3c86986"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaffd504b8f02006532dd611f3c86986">context_req</a></td></tr>
<tr class="memdesc:aeaffd504b8f02006532dd611f3c86986"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context requirements flags as an int value specific to the context provider.  <br /></td></tr>
<tr class="separator:aeaffd504b8f02006532dd611f3c86986"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aabe11b054aad90558283db408c0d80b0" id="r_aabe11b054aad90558283db408c0d80b0"><td class="memItemLeft" align="right" valign="top">typing.List[typing.Tuple[<a class="el" href="classspnego_1_1__context_1_1_context_req.html">ContextReq</a>, int]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabe11b054aad90558283db408c0d80b0">_context_attr_map</a> (self)</td></tr>
<tr class="separator:aabe11b054aad90558283db408c0d80b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2355b1a46887a6d217471b40b502d9" id="r_a8d2355b1a46887a6d217471b40b502d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d2355b1a46887a6d217471b40b502d9">_requires_mech_list_mic</a> (self)</td></tr>
<tr class="separator:a8d2355b1a46887a6d217471b40b502d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a06013d07726eed325148bd2cad767" id="r_ae1a06013d07726eed325148bd2cad767"><td class="memItemLeft" align="right" valign="top">typing.List[<a class="el" href="namespacespnego_1_1__context.html#a3e9640f3170851228c847c88900a3b64">NativeIOV</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1a06013d07726eed325148bd2cad767">_build_iov_list</a> (self, typing.Iterable[<a class="el" href="namespacespnego_1_1__context.html#a62693a779f0b7b7b550735696ecab364">IOV</a>] iov, typing.Callable[[<a class="el" href="classspnego_1_1iov_1_1_i_o_v_buffer.html">IOVBuffer</a>], <a class="el" href="namespacespnego_1_1__context.html#a3e9640f3170851228c847c88900a3b64">NativeIOV</a>] native_convert)</td></tr>
<tr class="memdesc:ae1a06013d07726eed325148bd2cad767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a list of IOV buffers for the native provider needed.  <br /></td></tr>
<tr class="separator:ae1a06013d07726eed325148bd2cad767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ff42583d5f147c13a3f46bd6c10120" id="r_a40ff42583d5f147c13a3f46bd6c10120"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40ff42583d5f147c13a3f46bd6c10120">_reset_ntlm_crypto_state</a> (self, bool outgoing=True)</td></tr>
<tr class="memdesc:a40ff42583d5f147c13a3f46bd6c10120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the NTLM crypto handles after signing/verifying the SPNEGO mechListMIC.  <br /></td></tr>
<tr class="separator:a40ff42583d5f147c13a3f46bd6c10120"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a22d9c68b5604aa8b18aa4bbed03280a3" id="r_a22d9c68b5604aa8b18aa4bbed03280a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22d9c68b5604aa8b18aa4bbed03280a3">_hostname</a></td></tr>
<tr class="separator:a22d9c68b5604aa8b18aa4bbed03280a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e415fd14e3668b5748f64503e188ec" id="r_ab2e415fd14e3668b5748f64503e188ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2e415fd14e3668b5748f64503e188ec">_service</a></td></tr>
<tr class="separator:ab2e415fd14e3668b5748f64503e188ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69b7548769f56420bb701b20593ee24" id="r_aa69b7548769f56420bb701b20593ee24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa69b7548769f56420bb701b20593ee24">_context_req</a></td></tr>
<tr class="separator:aa69b7548769f56420bb701b20593ee24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b7127d5add83da074f199ba4090596" id="r_ac1b7127d5add83da074f199ba4090596"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1b7127d5add83da074f199ba4090596">_context_attr</a></td></tr>
<tr class="separator:ac1b7127d5add83da074f199ba4090596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017672475ad92e0e21ef8705225718ed" id="r_a017672475ad92e0e21ef8705225718ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a017672475ad92e0e21ef8705225718ed">_is_wrapped</a></td></tr>
<tr class="separator:a017672475ad92e0e21ef8705225718ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="properties" name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:af150fae3ae24c0a74d4da3f971177f03" id="r_af150fae3ae24c0a74d4da3f971177f03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af150fae3ae24c0a74d4da3f971177f03">username</a> = property</td></tr>
<tr class="separator:af150fae3ae24c0a74d4da3f971177f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3296b0ce5fd9cb6e879ea525d86f745e" id="r_a3296b0ce5fd9cb6e879ea525d86f745e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3296b0ce5fd9cb6e879ea525d86f745e">password</a> = property</td></tr>
<tr class="separator:a3296b0ce5fd9cb6e879ea525d86f745e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22185ebbea09334acdab8891f46e1a7" id="r_ad22185ebbea09334acdab8891f46e1a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad22185ebbea09334acdab8891f46e1a7">client_principal</a> = property</td></tr>
<tr class="memdesc:ad22185ebbea09334acdab8891f46e1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The principal that was used authenticated by the acceptor.  <br /></td></tr>
<tr class="separator:ad22185ebbea09334acdab8891f46e1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dc905fe8fb0f22daa2bc0e312320da" id="r_a26dc905fe8fb0f22daa2bc0e312320da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26dc905fe8fb0f22daa2bc0e312320da">complete</a> = property</td></tr>
<tr class="memdesc:a26dc905fe8fb0f22daa2bc0e312320da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the context has completed the authentication process.  <br /></td></tr>
<tr class="separator:a26dc905fe8fb0f22daa2bc0e312320da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae348ab41dcb333ec50f873b7bfea0a8b" id="r_ae348ab41dcb333ec50f873b7bfea0a8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae348ab41dcb333ec50f873b7bfea0a8b">context_attr</a> = property</td></tr>
<tr class="memdesc:ae348ab41dcb333ec50f873b7bfea0a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context attributes that were negotiated.  <br /></td></tr>
<tr class="separator:ae348ab41dcb333ec50f873b7bfea0a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5bf84ae611eb7d11ba98dd9e0c7354" id="r_a8c5bf84ae611eb7d11ba98dd9e0c7354"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c5bf84ae611eb7d11ba98dd9e0c7354">negotiated_protocol</a> = property</td></tr>
<tr class="memdesc:a8c5bf84ae611eb7d11ba98dd9e0c7354"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the negotiated protocol.  <br /></td></tr>
<tr class="separator:a8c5bf84ae611eb7d11ba98dd9e0c7354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3263b25c430995f41609f166e15a4567" id="r_a3263b25c430995f41609f166e15a4567"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3263b25c430995f41609f166e15a4567">session_key</a> = property</td></tr>
<tr class="memdesc:a3263b25c430995f41609f166e15a4567"><td class="mdescLeft">&#160;</td><td class="mdescRight">The derived session key.  <br /></td></tr>
<tr class="separator:a3263b25c430995f41609f166e15a4567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fdbf5a26f7a7e30ad19e605071f266" id="r_a70fdbf5a26f7a7e30ad19e605071f266"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70fdbf5a26f7a7e30ad19e605071f266">_context_attr_map</a> = property</td></tr>
<tr class="memdesc:a70fdbf5a26f7a7e30ad19e605071f266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the generic ContextReq into the provider specific flags.  <br /></td></tr>
<tr class="separator:a70fdbf5a26f7a7e30ad19e605071f266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cee04743b47481845fdce68ef1f567" id="r_a65cee04743b47481845fdce68ef1f567"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65cee04743b47481845fdce68ef1f567">_requires_mech_list_mic</a> = property</td></tr>
<tr class="memdesc:a65cee04743b47481845fdce68ef1f567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the SPNEGO mechListMIC is required for the sec context.  <br /></td></tr>
<tr class="separator:a65cee04743b47481845fdce68ef1f567"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for a authentication context. </p>
<p>A base class the defined a common entry point for the various authentication context's that are used in this library. For a new context to be added it must implement the abstract functions in this class and translate the calls to what is required internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">credentials</td><td>A list of credentials to use for authentication. </td></tr>
    <tr><td class="paramname">hostname</td><td>The principal part of the SPN. This is required for Kerberos auth to build the SPN. </td></tr>
    <tr><td class="paramname">service</td><td>The service part of the SPN. This is required for Kerberos auth to build the SPN. </td></tr>
    <tr><td class="paramname">channel_bindings</td><td>The optional :class:<code><a class="el" href="classspnego_1_1channel__bindings_1_1_gss_channel_bindings.html" title="Python representation of a GSSAPI Channel Binding data structure.">spnego.channel_bindings.GssChannelBindings</a></code> for the context. </td></tr>
    <tr><td class="paramname">context_req</td><td>The :class:<code>spnego.ContextReq</code> flags to use when setting up the context. </td></tr>
    <tr><td class="paramname">usage</td><td>The usage of the context, <code>initiate</code> for a client and <code>accept</code> for a server. </td></tr>
    <tr><td class="paramname">protocol</td><td>The protocol to authenticate with, can be <code>ntlm</code>, <code>kerberos</code>, or <code>negotiate</code>. Not all providers support all three protocols as that is handled by :class:<code>SPNEGOContext</code>. </td></tr>
    <tr><td class="paramname">options</td><td>The :class:<code>spnego.NegotiateOptions</code> that define pyspnego specific options to control the negotiation. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac1cef0762f9713239569bd6a72a7e485" name="ac1cef0762f9713239569bd6a72a7e485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cef0762f9713239569bd6a72a7e485">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None spnego._context.ContextProxy.__init__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.List[Credential]</td>          <td class="paramname"><span class="paramname"><em>credentials</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[str]</td>          <td class="paramname"><span class="paramname"><em>hostname</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[str]</td>          <td class="paramname"><span class="paramname"><em>service</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[<a class="el" href="classspnego_1_1channel__bindings_1_1_gss_channel_bindings.html">GssChannelBindings</a>]</td>          <td class="paramname"><span class="paramname"><em>channel_bindings</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classspnego_1_1__context_1_1_context_req.html">ContextReq</a></td>          <td class="paramname"><span class="paramname"><em>context_req</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>usage</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>protocol</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classspnego_1_1exceptions_1_1_negotiate_options.html">NegotiateOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#abd235212e9232bcce331a9cacca7c98b">spnego._sspi.SSPIProxy</a>, <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#a50af5db0553e1fd0addb392f5bd7d824">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#af8d0eac8f3f193eaaec30586859a8ce4">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#abb1f46d42729d287b48f4bda049220d6">spnego._negotiate.NegotiateProxy</a>, and <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#a88b04bb0f40a5d485e40b07e9aae0740">spnego._ntlm.NTLMProxy</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1a06013d07726eed325148bd2cad767" name="ae1a06013d07726eed325148bd2cad767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a06013d07726eed325148bd2cad767">&#9670;&#160;</a></span>_build_iov_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> typing.List[<a class="el" href="namespacespnego_1_1__context.html#a3e9640f3170851228c847c88900a3b64">NativeIOV</a>] spnego._context.ContextProxy._build_iov_list </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Iterable[<a class="el" href="namespacespnego_1_1__context.html#a62693a779f0b7b7b550735696ecab364">IOV</a>]</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Callable[[<a class="el" href="classspnego_1_1iov_1_1_i_o_v_buffer.html">IOVBuffer</a>], <a class="el" href="namespacespnego_1_1__context.html#a3e9640f3170851228c847c88900a3b64">NativeIOV</a>]
    </td>          <td class="paramname"><span class="paramname"><em>native_convert</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a list of IOV buffers for the native provider needed. </p>

</div>
</div>
<a id="aabe11b054aad90558283db408c0d80b0" name="aabe11b054aad90558283db408c0d80b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe11b054aad90558283db408c0d80b0">&#9670;&#160;</a></span>_context_attr_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> typing.List[typing.Tuple[<a class="el" href="classspnego_1_1__context_1_1_context_req.html">ContextReq</a>, int]] spnego._context.ContextProxy._context_attr_map </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#a4a039708a737fcd4a8e255b55cc89dc1">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a91057a77852d299d0f22d5af21e00fa6">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a8d91c93de28712d58e30b9a65ee3b2c8">spnego._negotiate.NegotiateProxy</a>, <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#aea528734763d55ee3844dcac35f55190">spnego._ntlm.NTLMProxy</a>, and <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a08420db29e16c304ca1978b2b65fc07a">spnego._sspi.SSPIProxy</a>.</p>

</div>
</div>
<a id="a8d2355b1a46887a6d217471b40b502d9" name="a8d2355b1a46887a6d217471b40b502d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2355b1a46887a6d217471b40b502d9">&#9670;&#160;</a></span>_requires_mech_list_mic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool spnego._context.ContextProxy._requires_mech_list_mic </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a6107c9877d431810976271d6958d7808">spnego._negotiate.NegotiateProxy</a>, and <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#a2c7394bff30af4d97b55c3520b0cea74">spnego._ntlm.NTLMProxy</a>.</p>

</div>
</div>
<a id="a40ff42583d5f147c13a3f46bd6c10120" name="a40ff42583d5f147c13a3f46bd6c10120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ff42583d5f147c13a3f46bd6c10120">&#9670;&#160;</a></span>_reset_ntlm_crypto_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None spnego._context.ContextProxy._reset_ntlm_crypto_state </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>outgoing</em><span class="paramdefsep"> = </span><span class="paramdefval">True</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the NTLM crypto handles after signing/verifying the SPNEGO mechListMIC. </p>
<pre class="fragment">   `MS-SPNG`_ documents that after signing or verifying the mechListMIC, the RC4 key state needs to be the same
   for the mechListMIC and for the first message signed/sealed by the application. Because we use SSPI on Windows
   hosts which does all the work for us this function only matters for Linux hosts.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outgoing</td><td>Whether to reset the outgoing or incoming RC4 key state. <pre class="fragment">   .. _MS-SPNG:
       https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-spng/b87587b3-9d72-4027-8131-b76b5368115f
</pre> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#ace64e160f45f4958480a52a678346084">spnego._negotiate.NegotiateProxy</a>, and <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#a21fd8cb3defa8dbaf0eb394d11c52f11">spnego._ntlm.NTLMProxy</a>.</p>

</div>
</div>
<a id="ac0285d1a81f7c7377bed8fff18a48207" name="ac0285d1a81f7c7377bed8fff18a48207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0285d1a81f7c7377bed8fff18a48207">&#9670;&#160;</a></span>available_protocols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> typing.List[str] spnego._context.ContextProxy.available_protocols </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cls</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[<a class="el" href="classspnego_1_1exceptions_1_1_negotiate_options.html">NegotiateOptions</a>] </td>          <td class="paramname"><span class="paramname"><em>options</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of protocols that the provider can offer. </p>
<pre class="fragment">   Returns a list of protocols the underlying provider can implement. Currently only kerberos, negotiate, or ntlm
   is understood. The protocols that are available for each proxy context depend on the OS platform and what
   libraries are installed. See each proxy's `available_protocols` function for more info.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>The context requirements of :class:<code>NegotiationOptions</code> that state what the client requires.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
List The list of protocols that the context can use. </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a3269a1ab0d3141465c8d5ceb995a2846">spnego._sspi.SSPIProxy</a>, <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#a26bde9f697b4c84232b0b242131ac723">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a0080a355dd604d2876a858712e34f037">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#ac36b814a16090bc41c234ac48be251c2">spnego._negotiate.NegotiateProxy</a>, and <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#a05b343cffbcff826e83f1c22035c2ac6">spnego._ntlm.NTLMProxy</a>.</p>

</div>
</div>
<a id="aed04bf7aa25e4060d3ffd9f2e5d440f8" name="aed04bf7aa25e4060d3ffd9f2e5d440f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed04bf7aa25e4060d3ffd9f2e5d440f8">&#9670;&#160;</a></span>get_extra_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> typing.Any spnego._context.ContextProxy.get_extra_info </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Any </td>          <td class="paramname"><span class="paramname"><em>default</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return information about the security context. </p>
<pre class="fragment">   Returns extra information about the security context that is not defined
   as part of the standard :class:`ContextProxy` attributes or properties.
   By default there is no context specific information and it's up to the
   sub classes to implement their own.

   These names can be queried for a CredSSP context.

       client_credential:
           Used on an `acceptor` CredSSP context and contains the delegated
           credential sent by the client to the server. This is only
           available once the context is complete otherwise the default
           value is returned. The types returned can be
           :class:`TSPasswordCreds`, :class:`TSSmartCardCreds`, or
           :class:`TSRemoteGuardCreds`.

       sslcontext:
           The :class:`ssl.SSLContext` instance used for the CredSSP
           context.

       ssl_object:
           The :class:`ssl.SSLObject` instance used for the CredSSP
           context.
</pre><p> auth_stage added in 0.5.0: A string representing that sub authentication stage being performed in the CredSSP authentication stepping. The value here is meant to be a human friendly representation and not something to be relied upon.</p>
<p>protocol_version added in 0.5.0: The CredSSP protocol version that was negotiated between the initiator and acceptor. This is the minimum version number offered by both parties once the Negotiate authentication stage is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name/id of the information to retrieve. </td></tr>
    <tr><td class="paramname">default</td><td>The default value to return if the information is not available on the current context proxy.</td></tr>
    <tr><td class="paramname">name</td><td>The name/id of the information to retrieve. </td></tr>
    <tr><td class="paramname">default</td><td>The default value to return if the information is not available on the current context proxy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The information requested or the default value specified if the information isn't found. </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#ac65e71bd225443373063ba7d93d89af0">spnego._credssp.CredSSPProxy</a>.</p>

</div>
</div>
<a id="a02013b11bc695163a0ecb5562bc6a8de" name="a02013b11bc695163a0ecb5562bc6a8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02013b11bc695163a0ecb5562bc6a8de">&#9670;&#160;</a></span>iov_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool spnego._context.ContextProxy.iov_available </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cls</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the context supports IOV wrapping and unwrapping. </p>
<pre class="fragment">   Will return a bool that states whether the context supports IOV wrapping or unwrapping. The NTLM protocol on
   Linux does not support IOV and some Linux gssapi implementations do not expose the extension headers for this
   function. This gives the caller a sane way to determine whether it can use :meth:`wrap_iov` or
   :meth:`unwrap_iov`.
</pre> <dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
bool Whether the context provider supports IOV wrapping and unwrapping (True) or not (False). </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#aee02ecf8a5fbd55ba047b84064a01dc4">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a145a49b00c1341e2969007e99eb8c3f7">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#ab9c44c0cea15351b0d7e88292fbd78d9">spnego._negotiate.NegotiateProxy</a>, and <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#aad0c2d111acc6b264335eb0907608338">spnego._ntlm.NTLMProxy</a>.</p>

</div>
</div>
<a id="a87bb4cfcf1874549610c896328965b0c" name="a87bb4cfcf1874549610c896328965b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bb4cfcf1874549610c896328965b0c">&#9670;&#160;</a></span>new_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> &quot;ContextProxy&quot; spnego._context.ContextProxy.new_context </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new security context. </p>
<pre class="fragment">   Creates a new security context based on the current credential and
   options of the current context. This is useful when needing to set up a
   new security context without having to retrieve the credentials again.
</pre> <dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
ContextProxy The new security context. </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#a9ec15415bcabb7fbdb2a7a0d4f70dac0">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a1423c73f1e77627c12c15153e3240012">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a9c58a5c1cdb8ff62abc35d6e1f398a9b">spnego._negotiate.NegotiateProxy</a>, <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#a1008f78dd60aa21b0c509ce7e2cb9178">spnego._ntlm.NTLMProxy</a>, and <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a58aad0cc8af2f54e7e662b0ac3b851b5">spnego._sspi.SSPIProxy</a>.</p>

</div>
</div>
<a id="a23b3d00e12ed927a44f4a3ab63a139fd" name="a23b3d00e12ed927a44f4a3ab63a139fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b3d00e12ed927a44f4a3ab63a139fd">&#9670;&#160;</a></span>query_message_sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classspnego_1_1__context_1_1_sec_pkg_context_sizes.html">SecPkgContextSizes</a> spnego._context.ContextProxy.query_message_sizes </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the important structure sizes for message functions. </p>
<pre class="fragment">   Will get the important sizes for the various message functions used by
   the current authentication context. This must only be called once the
   context has been authenticated.
</pre> <dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
SecPkgContextSizes The sizes for the current context.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NoContextError</td><td>The security context is not ready to be queried. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#a14256df1bde9a23d04071186ce539069">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a349341807ae923deae3b1dc797de8fcb">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a836dc29c8d0bbb1e3da66a4a05c70b8f">spnego._negotiate.NegotiateProxy</a>, <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#ab3a316e66d85833485352d0521e46244">spnego._ntlm.NTLMProxy</a>, and <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a98af349a490560697063b09ccd0d897b">spnego._sspi.SSPIProxy</a>.</p>

</div>
</div>
<a id="a3e90e76c0bf92293d65c6c2d6da3507d" name="a3e90e76c0bf92293d65c6c2d6da3507d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e90e76c0bf92293d65c6c2d6da3507d">&#9670;&#160;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bytes spnego._context.ContextProxy.sign </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[int] </td>          <td class="paramname"><span class="paramname"><em>qop</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a signature/MIC for a message. </p>
<pre class="fragment">   This method generates a MIC for the given data. This is unlike wrap which bundles the MIC and the message
   together. The :meth:`verify` method can be used to verify a MIC.

   This is the equivalent to `gss_get_mic`_ for GSSAPI and `MakeSignature`_ for SSPI.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to generate the MIC for. </td></tr>
    <tr><td class="paramname">qop</td><td>The desired Quality of Protection (or None to use the default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
bytes The MIC for the data requested. <pre class="fragment">   .. _gss_get_mic:
       https://tools.ietf.org/html/rfc2744.html#section-5.15

   .. _MakeSignature:
       https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-makesignature
</pre> </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a7ff22050c75dd02c7193dfcec6625e6a">spnego._sspi.SSPIProxy</a>, <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#adae9a3edd6c99daf4f8402945bdcb269">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#aabfe8e8adbe28ea49cbbaeb742534f96">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a97f454438bbc47a3ff62b8ad095e1505">spnego._negotiate.NegotiateProxy</a>, and <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#ac6ca7cf10007ca1cbc5873e7b4201cad">spnego._ntlm.NTLMProxy</a>.</p>

</div>
</div>
<a id="a2dda293d7d52ac7273887f3d23bb2f9d" name="a2dda293d7d52ac7273887f3d23bb2f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dda293d7d52ac7273887f3d23bb2f9d">&#9670;&#160;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> typing.Optional[bytes] spnego._context.ContextProxy.step </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[bytes] </td>          <td class="paramname"><span class="paramname"><em>in_token</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*typing.Optional[<a class="el" href="classspnego_1_1channel__bindings_1_1_gss_channel_bindings.html">GssChannelBindings</a>] </td>          <td class="paramname"><span class="paramname"><em>channel_bindings</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a negotiation step. </p>
<pre class="fragment">   This method performs a negotiation step and processes/generates a token. This token should be then sent to the
   counterpart context to continue the authentication process.

   This should not be called once :meth:`complete` is True as the security context is complete.

   For the initiator this is equivalent to `gss_init_sec_context`_ for GSSAPI and `InitializeSecurityContext`_ for
   SSPI.

   For the acceptor this is equivalent to `gss_accept_sec_context`_ for GSSAPI and `AcceptSecurityContext`_ for
   SSPI.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_token</td><td>The input token to process (or None to process no input token). </td></tr>
    <tr><td class="paramname">channel_bindings</td><td>Optional channel bindings ot use in this step. Will take priority over channel bindings set in the context if both are specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
Optional The output token (or None if no output token is generated. <pre class="fragment">   .. _gss_init_sec_context:
       https://tools.ietf.org/html/rfc2744.html#section-5.19

   .. _InitializeSecurityContext:
       https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-initializesecuritycontextw

   .. _gss_accept_sec_context:
       https://tools.ietf.org/html/rfc2744.html#section-5.1

   .. _AcceptSecurityContext:
       https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-acceptsecuritycontext
</pre> </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a0eda3e874026395d45c3c366ee9decfe">spnego._sspi.SSPIProxy</a>, <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#a91163fd49932a3a3653b9cf9f733c1d7">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a8889aeb94903ceb01422763fefe371e2">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#ab84d8e5908cd1263c934bb2f308104a6">spnego._negotiate.NegotiateProxy</a>, and <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#afc6083bebd054321231f46df170426f7">spnego._ntlm.NTLMProxy</a>.</p>

</div>
</div>
<a id="ab59cc177e9f4a93a49454afb861fa3c1" name="ab59cc177e9f4a93a49454afb861fa3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59cc177e9f4a93a49454afb861fa3c1">&#9670;&#160;</a></span>unwrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classspnego_1_1__context_1_1_unwrap_result.html">UnwrapResult</a> spnego._context.ContextProxy.unwrap </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwrap a message. </p>
<pre class="fragment">   This unwraps a message created by :meth:`wrap`.

   This is the equivalent to `gss_unwrap`_ for GSSAPI and `DecryptMessage`_ for SSPI.

   The SSPI function's `DecryptMessage`_ is called with the following buffers::
</pre> <div class="fragment"><div class="line">SecBufferDesc(SECBUFFER_VERSION, [</div>
<div class="line">    SecBuffer(SECBUFFER_STREAM, len(data), data),</div>
<div class="line">    SecBuffer(SECBUFFER_DATA, 0, b<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">])</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to unwrap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
UnwrapResult The unwrapped message, whether it was encrypted, and the QoP used. <pre class="fragment">   .. _gss_unwrap:
       https://tools.ietf.org/html/rfc2744.html#section-5.31

   .. _DecryptMessage:
       https://docs.microsoft.com/en-us/windows/win32/secauthn/decryptmessage--general
</pre> </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#aa132071a04bffd37ff5c0be70e009515">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#adf6b8c7845f42182b0373f6f5a08b7f5">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a4e6f7a599c3b89cc200c4aa07dec9f2e">spnego._negotiate.NegotiateProxy</a>, <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#ade2be34bf851ce28c9d6a617b2dbeb80">spnego._ntlm.NTLMProxy</a>, and <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a7ad9c3db69c88fd1ccc091e92ddfcefe">spnego._sspi.SSPIProxy</a>.</p>

</div>
</div>
<a id="abc132845d3d714c4580bfa5aa137ee7c" name="abc132845d3d714c4580bfa5aa137ee7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc132845d3d714c4580bfa5aa137ee7c">&#9670;&#160;</a></span>unwrap_iov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classspnego_1_1__context_1_1_i_o_v_unwrap_result.html">IOVUnwrapResult</a> spnego._context.ContextProxy.unwrap_iov </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Iterable[<a class="el" href="namespacespnego_1_1__context.html#a62693a779f0b7b7b550735696ecab364">IOV</a>]</td>          <td class="paramname"><span class="paramname"><em>iov</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwrap/Decrypt an IOV buffer. </p>
<pre class="fragment">   This method unwraps/decrypts an IOV buffer. The IOV buffers control how the data is to be processed. Because
   IOV wrapping is an extension to GSSAPI and not implemented for NTLM on Linux, this method may not always be
   available to the caller. Check the :meth:`iov_available` property.

   This is the equivalent to `gss_unwrap_iov`_ for GSSAPI and `DecryptMessage`_ for SSPI.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iov</td><td>A list of :class:<code><a class="el" href="classspnego_1_1iov_1_1_i_o_v_buffer.html" title="A buffer to pass as a list to :meth:wrap_iov().">spnego.iov.IOVBuffer</a></code> buffers to unwrap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
IOVUnwrapResult The unwrapped buffer bytes, whether it was encrypted, and the QoP used. <pre class="fragment">   .. _gss_unwrap_iov:
       http://k5wiki.kerberos.org/wiki/Projects/GSSAPI_DCE

   .. _DecryptMessage:
       https://docs.microsoft.com/en-us/windows/win32/secauthn/decryptmessage--general
</pre> </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a7a895d8a073ded1f847d1278923b1b28">spnego._sspi.SSPIProxy</a>, <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#a9bd49a2fa6b7b788eabbb033d3970420">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a4c996a9b7da3477ffd5c082b6a973915">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a3d948973522beb6927ac6f9010345794">spnego._negotiate.NegotiateProxy</a>, and <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#ab524116b3915fa6e26e9626ddcd2a797">spnego._ntlm.NTLMProxy</a>.</p>

</div>
</div>
<a id="a924f37dc044d78c0b604bea12522ed01" name="a924f37dc044d78c0b604bea12522ed01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924f37dc044d78c0b604bea12522ed01">&#9670;&#160;</a></span>unwrap_winrm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bytes spnego._context.ContextProxy.unwrap_winrm </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes</td>          <td class="paramname"><span class="paramname"><em>header</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwrap/Decrypt a WinRM message. </p>
<pre class="fragment">   This method unwraps/decrypts a WinRM message. It handles the complexities of unwrapping the data and dealing
   with the various system library calls.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>The header portion of the WinRM wrapped result. </td></tr>
    <tr><td class="paramname">data</td><td>The data portion of the WinRM wrapped result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
bytes The unwrapped message. </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#a1f1b6918c6fa5ba908e8ff31f48e08d1">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a72938467471c415dd4bc0520c36f76a1">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a829d91e15738399d79ba2e9c37e07a16">spnego._negotiate.NegotiateProxy</a>, <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#ad93f17db4182725675000e2d274fd3a0">spnego._ntlm.NTLMProxy</a>, and <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a1ca345f43d6ee3cde5e3acbad58fe0bf">spnego._sspi.SSPIProxy</a>.</p>

</div>
</div>
<a id="a27cd2d0fe2a4fd5d458723e1bdf5c5f8" name="a27cd2d0fe2a4fd5d458723e1bdf5c5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cd2d0fe2a4fd5d458723e1bdf5c5f8">&#9670;&#160;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int spnego._context.ContextProxy.verify </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes</td>          <td class="paramname"><span class="paramname"><em>mic</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the signature/MIC for a message. </p>
<pre class="fragment">   Will verify that the given MIC matches the given data. If the MIC does not match the given data, an exception
   will be raised. The :meth:`sign` method can be used to sign data.

   This is the equivalent to `gss_verify_mic`_ for GSSAPI and `VerifySignature`_ for SSPI.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to verify against the MIC. </td></tr>
    <tr><td class="paramname">mic</td><td>The MIC to verify against the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
int The QoP (Quality of Protection) used. <pre class="fragment">   .. _gss_verify_mic:
       https://tools.ietf.org/html/rfc2744.html#section-5.32

   .. _VerifySignature:
       https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-verifysignature
</pre> </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#aa09ee8afdd8578ef3afb322f0e4f011d">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a9381204dbb323c4838a6fc8906ff9e00">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#ae570756a62ceeffc1d565253742fd316">spnego._negotiate.NegotiateProxy</a>, <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#a12ac0965f9393c7fcc3241c0437bc8d3">spnego._ntlm.NTLMProxy</a>, and <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a940fe02ebf0c6d68fda9a844033d1bf3">spnego._sspi.SSPIProxy</a>.</p>

</div>
</div>
<a id="a75488cc82ea1e23a105ca6bf3c3f4512" name="a75488cc82ea1e23a105ca6bf3c3f4512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75488cc82ea1e23a105ca6bf3c3f4512">&#9670;&#160;</a></span>wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classspnego_1_1__context_1_1_wrap_result.html">WrapResult</a> spnego._context.ContextProxy.wrap </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>encrypt</em><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[int] </td>          <td class="paramname"><span class="paramname"><em>qop</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a message, optionally with encryption. </p>
<pre class="fragment">   This wraps a message, signing it and optionally encrypting it. The :meth:`unwrap` will unwrap a message.

   This is the equivalent to `gss_wrap`_ for GSSAPI and `EncryptMessage`_ for SSPI.

   The SSPI function's `EncryptMessage`_ is called with the following buffers::
</pre> <div class="fragment"><div class="line">SecBufferDesc(SECBUFFER_VERSION, [</div>
<div class="line">    SecBuffer(SECBUFFER_TOKEN, sizes.cbSecurityTrailer, b<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">    SecBuffer(SECBUFFER_DATA, len(data), data),</div>
<div class="line">    SecBuffer(SECBUFFER_PADDING, sizes.cbBlockSize, b<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">])</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to wrap. </td></tr>
    <tr><td class="paramname">encrypt</td><td>Whether to encrypt the data (True) or just wrap it with a MIC (False). </td></tr>
    <tr><td class="paramname">qop</td><td>The desired Quality of Protection (or None to use the default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
WrapResult The wrapped result which contains the wrapped message and whether it was encrypted or not. <pre class="fragment">   .. _gss_wrap:
       https://tools.ietf.org/html/rfc2744.html#section-5.33

   .. _EncryptMessage:
       https://docs.microsoft.com/en-us/windows/win32/secauthn/encryptmessage--general
</pre> </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a96f748e55355762e533731456d4e93cb">spnego._sspi.SSPIProxy</a>, <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#af0a84db32baa2d1f84ab19cb2f758b87">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a50ba7abebdfe882474f1c384e75dd065">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#ab8e39befda9149a77a87d511fd173d60">spnego._negotiate.NegotiateProxy</a>, and <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#a5b302fd5ba2d57885bc99aeac3e338c7">spnego._ntlm.NTLMProxy</a>.</p>

</div>
</div>
<a id="aedd4bce65af1dbca62ceb3460457ad62" name="aedd4bce65af1dbca62ceb3460457ad62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd4bce65af1dbca62ceb3460457ad62">&#9670;&#160;</a></span>wrap_iov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classspnego_1_1__context_1_1_i_o_v_wrap_result.html">IOVWrapResult</a> spnego._context.ContextProxy.wrap_iov </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Iterable[<a class="el" href="namespacespnego_1_1__context.html#a62693a779f0b7b7b550735696ecab364">IOV</a>]</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>encrypt</em><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[int] </td>          <td class="paramname"><span class="paramname"><em>qop</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap/Encrypt an IOV buffer. </p>
<pre class="fragment">   This method wraps/encrypts an IOV buffer. The IOV buffers control how the data is to be processed. Because
   IOV wrapping is an extension to GSSAPI and not implemented for NTLM on Linux, this method may not always be
   available to the caller. Check the :meth:`iov_available` property.

   This is the equivalent to `gss_wrap_iov`_ for GSSAPI and `EncryptMessage`_ for SSPI.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iov</td><td>A list of :class:<code><a class="el" href="classspnego_1_1iov_1_1_i_o_v_buffer.html" title="A buffer to pass as a list to :meth:wrap_iov().">spnego.iov.IOVBuffer</a></code> buffers to wrap. </td></tr>
    <tr><td class="paramname">encrypt</td><td>Whether to encrypt the message (True) or just wrap it with a MIC (False). </td></tr>
    <tr><td class="paramname">qop</td><td>The desired Quality of Protection (or None to use the default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
IOVWrapResult The wrapped result which contains the wrapped IOVBuffer bytes and whether it was encrypted or not.</dd></dl>
<p>.. _gss_wrap_iov: <a href="http://k5wiki.kerberos.org/wiki/Projects/GSSAPI_DCE">http://k5wiki.kerberos.org/wiki/Projects/GSSAPI_DCE</a></p>
<p>.. _EncryptMessage: <a href="https://docs.microsoft.com/en-us/windows/win32/secauthn/encryptmessage&ndash;general">https://docs.microsoft.com/en-us/windows/win32/secauthn/encryptmessage&amp;ndash;general</a> </p>

<p>Reimplemented in <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#ae2542433cb6172cb68d95b366af498d2">spnego._sspi.SSPIProxy</a>, <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#abae43616778e68b999f37e6c462e70b0">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a9c5f65fa9c6583ab59eb67540be76db2">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a8bceddcac1f062cbdaeb2da5d2b451f3">spnego._negotiate.NegotiateProxy</a>, and <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#a145cd294748002c99f83c9b11810708d">spnego._ntlm.NTLMProxy</a>.</p>

</div>
</div>
<a id="a9c9e37d5346f5bdfc06faacc6dd29985" name="a9c9e37d5346f5bdfc06faacc6dd29985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9e37d5346f5bdfc06faacc6dd29985">&#9670;&#160;</a></span>wrap_winrm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classspnego_1_1__context_1_1_win_r_m_wrap_result.html">WinRMWrapResult</a> spnego._context.ContextProxy.wrap_winrm </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap/Encrypt data for use with WinRM. </p>
<pre class="fragment">   This method wraps/encrypts bytes for use with WinRM message encryption.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to wrap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
WinRMWrapResult The wrapped result for use with WinRM message encryption. </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#a0a1ee90c3bb1e7de2cc83b62c3a5036b">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#ad68c50b379a20a7fa4b3f030d119b7d2">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a5155c1750ab96d3971f43956f51ea9fd">spnego._negotiate.NegotiateProxy</a>, <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#a2d38078eb5dbb59dfa7948cb1b956224">spnego._ntlm.NTLMProxy</a>, and <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#af97da6665477b35c2bf9c7d353e3ba7c">spnego._sspi.SSPIProxy</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac1b7127d5add83da074f199ba4090596" name="ac1b7127d5add83da074f199ba4090596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b7127d5add83da074f199ba4090596">&#9670;&#160;</a></span>_context_attr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy._context_attr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa69b7548769f56420bb701b20593ee24" name="aa69b7548769f56420bb701b20593ee24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69b7548769f56420bb701b20593ee24">&#9670;&#160;</a></span>_context_req</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy._context_req</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22d9c68b5604aa8b18aa4bbed03280a3" name="a22d9c68b5604aa8b18aa4bbed03280a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d9c68b5604aa8b18aa4bbed03280a3">&#9670;&#160;</a></span>_hostname</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy._hostname</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a017672475ad92e0e21ef8705225718ed" name="a017672475ad92e0e21ef8705225718ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017672475ad92e0e21ef8705225718ed">&#9670;&#160;</a></span>_is_wrapped</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy._is_wrapped</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2e415fd14e3668b5748f64503e188ec" name="ab2e415fd14e3668b5748f64503e188ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e415fd14e3668b5748f64503e188ec">&#9670;&#160;</a></span>_service</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy._service</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed0fe31dc278e3ca90571adbfab35738" name="aed0fe31dc278e3ca90571adbfab35738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0fe31dc278e3ca90571adbfab35738">&#9670;&#160;</a></span>channel_bindings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.channel_bindings</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional channel bindings to provide with the. </p>

</div>
</div>
<a id="aeaffd504b8f02006532dd611f3c86986" name="aeaffd504b8f02006532dd611f3c86986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaffd504b8f02006532dd611f3c86986">&#9670;&#160;</a></span>context_req</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.context_req</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The context requirements flags as an int value specific to the context provider. </p>

</div>
</div>
<a id="acd185878b1e6f3971fbc04a030450a1e" name="acd185878b1e6f3971fbc04a030450a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd185878b1e6f3971fbc04a030450a1e">&#9670;&#160;</a></span>options</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.options</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user specified negotiation options. </p>

</div>
</div>
<a id="a8d4c501ab00f466a4613b5a086877641" name="a8d4c501ab00f466a4613b5a086877641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4c501ab00f466a4613b5a086877641">&#9670;&#160;</a></span>protocol</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.protocol</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The protocol to set the context up with; <code>ntlm</code>, <code>kerberos</code>, or <code>negotiate</code>. </p>

</div>
</div>
<a id="ae23d81f74241011b397ab00cecbd9801" name="ae23d81f74241011b397ab00cecbd9801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23d81f74241011b397ab00cecbd9801">&#9670;&#160;</a></span>spn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.spn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The service principal name of the service to connect to. </p>

</div>
</div>
<a id="a6202a97e29287e5eb8e378b02c59ddfc" name="a6202a97e29287e5eb8e378b02c59ddfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6202a97e29287e5eb8e378b02c59ddfc">&#9670;&#160;</a></span>usage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.usage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The usage of the context, <code>initiate</code> for a client and <code>accept</code> for a server. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a70fdbf5a26f7a7e30ad19e605071f266" name="a70fdbf5a26f7a7e30ad19e605071f266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fdbf5a26f7a7e30ad19e605071f266">&#9670;&#160;</a></span>_context_attr_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy._context_attr_map = property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map the generic ContextReq into the provider specific flags. </p>
<pre class="fragment">   Will return a list of tuples that give the provider specific flag value for the generic ContextReq that is
   exposed to end users.
</pre> <dl class="section return"><dt>Returns</dt><dd>List[Tuple[ContextReq, int], ...]: A list of tuples where tuple[0] is the ContextReq flag and tuple[1] is the relevant provider specific flag for our common one. </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__credssp_1_1_cred_s_s_p_proxy.html#a4a039708a737fcd4a8e255b55cc89dc1">spnego._credssp.CredSSPProxy</a>, <a class="el" href="classspnego_1_1__gss_1_1_g_s_s_a_p_i_proxy.html#a91057a77852d299d0f22d5af21e00fa6">spnego._gss.GSSAPIProxy</a>, <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a8d91c93de28712d58e30b9a65ee3b2c8">spnego._negotiate.NegotiateProxy</a>, <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#aea528734763d55ee3844dcac35f55190">spnego._ntlm.NTLMProxy</a>, and <a class="el" href="classspnego_1_1__sspi_1_1_s_s_p_i_proxy.html#a08420db29e16c304ca1978b2b65fc07a">spnego._sspi.SSPIProxy</a>.</p>

</div>
</div>
<a id="a65cee04743b47481845fdce68ef1f567" name="a65cee04743b47481845fdce68ef1f567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cee04743b47481845fdce68ef1f567">&#9670;&#160;</a></span>_requires_mech_list_mic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy._requires_mech_list_mic = property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the SPNEGO mechListMIC is required for the sec context. </p>
<pre class="fragment">   When Microsoft hosts deal with NTLM through SPNEGO it always wants the mechListMIC to be present when the NTLM
   authentication message contains a MIC. This goes against RFC 4178 as a mechListMIC shouldn't be required if
   NTLM was the preferred mech from the initiator but we can't do anything about that now. Because we exclusively
   use SSPI on Windows hosts, which does all the work for us, this function only matter for Linux hosts when this
   library manually creates the SPNEGO token.

   The function performs 2 operations. When called before the NTLM authentication message has been created it
   tells the gss-ntlmssp mech that it's ok to generate the MIC. When the authentication message has been created
   it returns a bool stating whether the MIC was present in the auth message and subsequently whether we need to
   include the mechListMIC in the SPNEGO token.

   See `mech_required_mechlistMIC in MIT KRB5`_ for more information about how MIT KRB5 deals with this.
</pre> <dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
bool Whether the SPNEGO mechListMIC needs to be generated or not. <pre class="fragment">   .. _mech_requires_mechlistMIC:
       https://github.com/krb5/krb5/blob/b2fe66fed560ae28917a4acae6f6c0f020156353/src/lib/gssapi/spnego/spnego_mech.c#L493
</pre> </dd></dl>

<p>Reimplemented in <a class="el" href="classspnego_1_1__negotiate_1_1_negotiate_proxy.html#a6107c9877d431810976271d6958d7808">spnego._negotiate.NegotiateProxy</a>, and <a class="el" href="classspnego_1_1__ntlm_1_1_n_t_l_m_proxy.html#a2c7394bff30af4d97b55c3520b0cea74">spnego._ntlm.NTLMProxy</a>.</p>

</div>
</div>
<a id="ad22185ebbea09334acdab8891f46e1a7" name="ad22185ebbea09334acdab8891f46e1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22185ebbea09334acdab8891f46e1a7">&#9670;&#160;</a></span>client_principal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.client_principal = property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The principal that was used authenticated by the acceptor. </p>
<pre class="fragment">   The name of the client principal that was used in the authentication context. This is `None` when
   `usage='initiate'` or the context has not been completed. The format of the principal name is dependent on the
   protocol and underlying library that was used to complete the authentication.
</pre> <dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
Optional The client principal name. </dd></dl>

</div>
</div>
<a id="a26dc905fe8fb0f22daa2bc0e312320da" name="a26dc905fe8fb0f22daa2bc0e312320da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dc905fe8fb0f22daa2bc0e312320da">&#9670;&#160;</a></span>complete</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.complete = property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the context has completed the authentication process. </p>
<pre class="fragment">   Will return a bool that states whether the authentication process has completed successfully.
</pre> <dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
bool The authentication process is complete (True) or not (False). </dd></dl>

</div>
</div>
<a id="ae348ab41dcb333ec50f873b7bfea0a8b" name="ae348ab41dcb333ec50f873b7bfea0a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae348ab41dcb333ec50f873b7bfea0a8b">&#9670;&#160;</a></span>context_attr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.context_attr = property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The context attributes that were negotiated. </p>
<pre class="fragment">   This is the context attributes that were negotiated with the counterpart server. These attributes are only
   valid once the context is fully established.
</pre> <dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
ContextReq The flags that were negotiated. </dd></dl>

</div>
</div>
<a id="a8c5bf84ae611eb7d11ba98dd9e0c7354" name="a8c5bf84ae611eb7d11ba98dd9e0c7354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5bf84ae611eb7d11ba98dd9e0c7354">&#9670;&#160;</a></span>negotiated_protocol</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.negotiated_protocol = property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the negotiated protocol. </p>
<pre class="fragment">   Once the authentication process has compeleted this will return the name of the negotiated context that was
   used. For pure NTLM and Kerberos this will always be `ntlm` or `kerberos` respectively but for SPNEGO this can
   be either of those two.
</pre> <dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
Optional The protocol that was negotiated, can be <code>ntlm</code>, <code>kerberos</code>, or <code>negotiate. Will be</code>None<code> for the acceptor until it receives the first token from the initiator. Once the context is establish </code>negotiate<code>will change to either</code>ntlm<code>or</code>kerberos` to reflect the protocol that was used by SPNEGO. </dd></dl>

</div>
</div>
<a id="a3296b0ce5fd9cb6e879ea525d86f745e" name="a3296b0ce5fd9cb6e879ea525d86f745e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3296b0ce5fd9cb6e879ea525d86f745e">&#9670;&#160;</a></span>password</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.password = property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3263b25c430995f41609f166e15a4567" name="a3263b25c430995f41609f166e15a4567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3263b25c430995f41609f166e15a4567">&#9670;&#160;</a></span>session_key</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.session_key = property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The derived session key. </p>
<pre class="fragment">   Once the authentication process is complete, this will return the derived session key. It is recommended to not
   use this key for your own encryption processes and is only exposed because some libraries use this key in their
   protocols.
</pre> <dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
bytes The derived session key from the authenticated context. </dd></dl>

</div>
</div>
<a id="af150fae3ae24c0a74d4da3f971177f03" name="af150fae3ae24c0a74d4da3f971177f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af150fae3ae24c0a74d4da3f971177f03">&#9670;&#160;</a></span>username</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spnego._context.ContextProxy.username = property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>venv/Lib/site-packages/spnego/<a class="el" href="__context_8py.html">_context.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
