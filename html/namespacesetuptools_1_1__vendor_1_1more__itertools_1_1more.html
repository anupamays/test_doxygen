<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: setuptools._vendor.more_itertools.more Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project<span id="projectnumber">&#160;Very early alpha</span>
   </div>
   <div id="projectbrief">integration testing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesetuptools.html">setuptools</a></li><li class="navelem"><a class="el" href="namespacesetuptools_1_1__vendor.html">_vendor</a></li><li class="navelem"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools.html">more_itertools</a></li><li class="navelem"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html">more</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">setuptools._vendor.more_itertools.more Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1_abort_thread.html">AbortThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1bucket.html">bucket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap <em>iterable</em> and return an object that buckets it iterable into child iterables based on a <em>key</em> function.  <a href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1bucket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1callback__iter.html">callback_iter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a function that uses callbacks to an iterator.  <a href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1callback__iter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1countable.html">countable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap <em>iterable</em> and keep a count of how many items have been consumed.  <a href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1countable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1islice__extended.html">islice_extended</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An extension of :func:<code>itertools.islice</code> that supports negative values for <em>stop</em>, <em>start</em>, and <em>step</em>.  <a href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1islice__extended.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1numeric__range.html">numeric_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An extension of the built-in <code>range()</code> function whose arguments can be any orderable numeric type.  <a href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1numeric__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1peekable.html">peekable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an iterator to allow lookahead and prepending elements.  <a href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1peekable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1run__length.html">run_length</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1seekable.html">seekable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an iterator to allow for seeking backward and forward.  <a href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1seekable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1_sequence_view.html">SequenceView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only view of the sequence object <em>target</em>.  <a href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1_sequence_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1time__limited.html">time_limited</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield items from <em>iterable</em> until <em>limit_seconds</em> have passed.  <a href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1time__limited.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1_unequal_iterables_error.html">UnequalIterablesError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abffb53abf1266b52e612759e97a93b4d" id="r_abffb53abf1266b52e612759e97a93b4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abffb53abf1266b52e612759e97a93b4d">chunked</a> (iterable, n, strict=False)</td></tr>
<tr class="memdesc:abffb53abf1266b52e612759e97a93b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break <em>iterable</em> into lists of length <em>n</em>:  <br /></td></tr>
<tr class="separator:abffb53abf1266b52e612759e97a93b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d65f68012304f562994508d19d68b4b" id="r_a3d65f68012304f562994508d19d68b4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d65f68012304f562994508d19d68b4b">first</a> (iterable, default=<a class="el" href="#ac9e7235e60a759a922fdec5a1c512922">_marker</a>)</td></tr>
<tr class="memdesc:a3d65f68012304f562994508d19d68b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first item of <em>iterable</em>, or <em>default</em> if <em>iterable</em> is empty.  <br /></td></tr>
<tr class="separator:a3d65f68012304f562994508d19d68b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8451a225701bd3bc60ca00f234062208" id="r_a8451a225701bd3bc60ca00f234062208"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8451a225701bd3bc60ca00f234062208">last</a> (iterable, default=<a class="el" href="#ac9e7235e60a759a922fdec5a1c512922">_marker</a>)</td></tr>
<tr class="memdesc:a8451a225701bd3bc60ca00f234062208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last item of <em>iterable</em>, or <em>default</em> if <em>iterable</em> is empty.  <br /></td></tr>
<tr class="separator:a8451a225701bd3bc60ca00f234062208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1c123134b401ca372bc206b6fae7ba" id="r_a7b1c123134b401ca372bc206b6fae7ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b1c123134b401ca372bc206b6fae7ba">nth_or_last</a> (iterable, n, default=<a class="el" href="#ac9e7235e60a759a922fdec5a1c512922">_marker</a>)</td></tr>
<tr class="memdesc:a7b1c123134b401ca372bc206b6fae7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nth or the last item of <em>iterable</em>, or <em>default</em> if <em>iterable</em> is empty.  <br /></td></tr>
<tr class="separator:a7b1c123134b401ca372bc206b6fae7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691dc99d522ad3defe468a1ee9bd532d" id="r_a691dc99d522ad3defe468a1ee9bd532d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a691dc99d522ad3defe468a1ee9bd532d">collate</a> (*iterables, **kwargs)</td></tr>
<tr class="memdesc:a691dc99d522ad3defe468a1ee9bd532d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted merge of the items from each of several already-sorted <em>iterables</em>.  <br /></td></tr>
<tr class="separator:a691dc99d522ad3defe468a1ee9bd532d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e66c12cc86c45187adb224fee478b" id="r_a227e66c12cc86c45187adb224fee478b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a227e66c12cc86c45187adb224fee478b">consumer</a> (func)</td></tr>
<tr class="memdesc:a227e66c12cc86c45187adb224fee478b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorator that automatically advances a PEP-342-style "reverse iterator" to its first yield point so you don't have to call <code>next()</code> on it manually.  <br /></td></tr>
<tr class="separator:a227e66c12cc86c45187adb224fee478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c69fff987516a452aa90c06d24885e" id="r_a64c69fff987516a452aa90c06d24885e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64c69fff987516a452aa90c06d24885e">ilen</a> (iterable)</td></tr>
<tr class="memdesc:a64c69fff987516a452aa90c06d24885e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items in <em>iterable</em>.  <br /></td></tr>
<tr class="separator:a64c69fff987516a452aa90c06d24885e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17348f255369895951eeb91ce27eab84" id="r_a17348f255369895951eeb91ce27eab84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17348f255369895951eeb91ce27eab84">iterate</a> (func, start)</td></tr>
<tr class="memdesc:a17348f255369895951eeb91ce27eab84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>start</code>, <code>func(start)</code>, <code>func(func(start))</code>, ...  <br /></td></tr>
<tr class="separator:a17348f255369895951eeb91ce27eab84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619447baa790cfa94d6bfc301c96a573" id="r_a619447baa790cfa94d6bfc301c96a573"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619447baa790cfa94d6bfc301c96a573">with_iter</a> (context_manager)</td></tr>
<tr class="memdesc:a619447baa790cfa94d6bfc301c96a573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an iterable in a <code>with</code> statement, so it closes once exhausted.  <br /></td></tr>
<tr class="separator:a619447baa790cfa94d6bfc301c96a573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c28ebee9cc10435df318256129637c0" id="r_a8c28ebee9cc10435df318256129637c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c28ebee9cc10435df318256129637c0">one</a> (iterable, too_short=None, too_long=None)</td></tr>
<tr class="memdesc:a8c28ebee9cc10435df318256129637c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first item from <em>iterable</em>, which is expected to contain only that item.  <br /></td></tr>
<tr class="separator:a8c28ebee9cc10435df318256129637c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8491276c50929899fe32cda6fd2d01e" id="r_ab8491276c50929899fe32cda6fd2d01e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8491276c50929899fe32cda6fd2d01e">distinct_permutations</a> (iterable, r=None)</td></tr>
<tr class="memdesc:ab8491276c50929899fe32cda6fd2d01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield successive distinct permutations of the elements in <em>iterable</em>.  <br /></td></tr>
<tr class="separator:ab8491276c50929899fe32cda6fd2d01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511fc6f0275c765800910360d1f96dc0" id="r_a511fc6f0275c765800910360d1f96dc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a511fc6f0275c765800910360d1f96dc0">intersperse</a> (e, iterable, n=1)</td></tr>
<tr class="memdesc:a511fc6f0275c765800910360d1f96dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersperse filler element <em>e</em> among the items in <em>iterable</em>, leaving <em>n</em> items between each filler element.  <br /></td></tr>
<tr class="separator:a511fc6f0275c765800910360d1f96dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bc505640cbe98f92a1703e472e1d00" id="r_ad5bc505640cbe98f92a1703e472e1d00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5bc505640cbe98f92a1703e472e1d00">unique_to_each</a> (*iterables)</td></tr>
<tr class="memdesc:ad5bc505640cbe98f92a1703e472e1d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elements from each of the input iterables that aren't in the other input iterables.  <br /></td></tr>
<tr class="separator:ad5bc505640cbe98f92a1703e472e1d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a25a63106c08986d199ddbd78d46277" id="r_a6a25a63106c08986d199ddbd78d46277"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a25a63106c08986d199ddbd78d46277">windowed</a> (seq, n, fillvalue=None, step=1)</td></tr>
<tr class="memdesc:a6a25a63106c08986d199ddbd78d46277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sliding window of width <em>n</em> over the given iterable.  <br /></td></tr>
<tr class="separator:a6a25a63106c08986d199ddbd78d46277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdc9a02ebf3b5ed801ceee08af6afb5" id="r_a0cdc9a02ebf3b5ed801ceee08af6afb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cdc9a02ebf3b5ed801ceee08af6afb5">substrings</a> (iterable)</td></tr>
<tr class="memdesc:a0cdc9a02ebf3b5ed801ceee08af6afb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield all of the substrings of <em>iterable</em>.  <br /></td></tr>
<tr class="separator:a0cdc9a02ebf3b5ed801ceee08af6afb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac255ef443ff15888f55c49aa1f070ff4" id="r_ac255ef443ff15888f55c49aa1f070ff4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac255ef443ff15888f55c49aa1f070ff4">substrings_indexes</a> (seq, reverse=False)</td></tr>
<tr class="memdesc:ac255ef443ff15888f55c49aa1f070ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield all substrings and their positions in <em>seq</em>  <br /></td></tr>
<tr class="separator:ac255ef443ff15888f55c49aa1f070ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad404f78ea35afd075654a37ad98a9426" id="r_ad404f78ea35afd075654a37ad98a9426"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad404f78ea35afd075654a37ad98a9426">spy</a> (iterable, n=1)</td></tr>
<tr class="memdesc:ad404f78ea35afd075654a37ad98a9426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 2-tuple with a list containing the first <em>n</em> elements of <em>iterable</em>, and an iterator with the same items as <em>iterable</em>.  <br /></td></tr>
<tr class="separator:ad404f78ea35afd075654a37ad98a9426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a550537ce14e8b31de79d09cbf72ab2" id="r_a6a550537ce14e8b31de79d09cbf72ab2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a550537ce14e8b31de79d09cbf72ab2">interleave</a> (*iterables)</td></tr>
<tr class="memdesc:a6a550537ce14e8b31de79d09cbf72ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new iterable yielding from each iterable in turn, until the shortest is exhausted.  <br /></td></tr>
<tr class="separator:a6a550537ce14e8b31de79d09cbf72ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1803700181e28e4201ab209a3da924d" id="r_aa1803700181e28e4201ab209a3da924d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1803700181e28e4201ab209a3da924d">interleave_longest</a> (*iterables)</td></tr>
<tr class="memdesc:aa1803700181e28e4201ab209a3da924d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new iterable yielding from each iterable in turn, skipping any that are exhausted.  <br /></td></tr>
<tr class="separator:aa1803700181e28e4201ab209a3da924d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41738788dce77084e613575a9391382" id="r_ad41738788dce77084e613575a9391382"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad41738788dce77084e613575a9391382">collapse</a> (iterable, base_type=None, levels=None)</td></tr>
<tr class="memdesc:ad41738788dce77084e613575a9391382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten an iterable with multiple levels of nesting (e.g., a list of lists of tuples) into non-iterable types.  <br /></td></tr>
<tr class="separator:ad41738788dce77084e613575a9391382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fd87a60e18304da46bc5b9b42b14b1" id="r_aa9fd87a60e18304da46bc5b9b42b14b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9fd87a60e18304da46bc5b9b42b14b1">side_effect</a> (func, iterable, chunk_size=None, before=None, after=None)</td></tr>
<tr class="memdesc:aa9fd87a60e18304da46bc5b9b42b14b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke <em>func</em> on each item in <em>iterable</em> (or on each <em>chunk_size</em> group of items) before yielding the item.  <br /></td></tr>
<tr class="separator:aa9fd87a60e18304da46bc5b9b42b14b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d69cf216f30f8434561bc98a0dd779" id="r_a56d69cf216f30f8434561bc98a0dd779"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56d69cf216f30f8434561bc98a0dd779">sliced</a> (seq, n, strict=False)</td></tr>
<tr class="memdesc:a56d69cf216f30f8434561bc98a0dd779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield slices of length <em>n</em> from the sequence <em>seq</em>.  <br /></td></tr>
<tr class="separator:a56d69cf216f30f8434561bc98a0dd779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c21ccdd1a1500b43fd08fe03f0f3c2c" id="r_a0c21ccdd1a1500b43fd08fe03f0f3c2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c21ccdd1a1500b43fd08fe03f0f3c2c">split_at</a> (iterable, pred, maxsplit=-1, keep_separator=False)</td></tr>
<tr class="memdesc:a0c21ccdd1a1500b43fd08fe03f0f3c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield lists of items from <em>iterable</em>, where each list is delimited by an item where callable <em>pred</em> returns <code>True</code>.  <br /></td></tr>
<tr class="separator:a0c21ccdd1a1500b43fd08fe03f0f3c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aee350818833ba18a93b952983d841" id="r_ad7aee350818833ba18a93b952983d841"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7aee350818833ba18a93b952983d841">split_before</a> (iterable, pred, maxsplit=-1)</td></tr>
<tr class="memdesc:ad7aee350818833ba18a93b952983d841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield lists of items from <em>iterable</em>, where each list ends just before an item for which callable <em>pred</em> returns <code>True</code>:  <br /></td></tr>
<tr class="separator:ad7aee350818833ba18a93b952983d841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec868cc95b2ee87797046cbf8083e47d" id="r_aec868cc95b2ee87797046cbf8083e47d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec868cc95b2ee87797046cbf8083e47d">split_after</a> (iterable, pred, maxsplit=-1)</td></tr>
<tr class="memdesc:aec868cc95b2ee87797046cbf8083e47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield lists of items from <em>iterable</em>, where each list ends with an item where callable <em>pred</em> returns <code>True</code>:  <br /></td></tr>
<tr class="separator:aec868cc95b2ee87797046cbf8083e47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524b6352594c860dfa3b742832d114aa" id="r_a524b6352594c860dfa3b742832d114aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a524b6352594c860dfa3b742832d114aa">split_when</a> (iterable, pred, maxsplit=-1)</td></tr>
<tr class="memdesc:a524b6352594c860dfa3b742832d114aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <em>iterable</em> into pieces based on the output of <em>pred</em>.  <br /></td></tr>
<tr class="separator:a524b6352594c860dfa3b742832d114aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2414703c881898f60f20d405da23acc0" id="r_a2414703c881898f60f20d405da23acc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2414703c881898f60f20d405da23acc0">split_into</a> (iterable, sizes)</td></tr>
<tr class="memdesc:a2414703c881898f60f20d405da23acc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield a list of sequential items from <em>iterable</em> of length 'n' for each integer 'n' in <em>sizes</em>.  <br /></td></tr>
<tr class="separator:a2414703c881898f60f20d405da23acc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50adbaec19127d43efcec83b3b67d2e1" id="r_a50adbaec19127d43efcec83b3b67d2e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50adbaec19127d43efcec83b3b67d2e1">padded</a> (iterable, fillvalue=None, n=None, next_multiple=False)</td></tr>
<tr class="memdesc:a50adbaec19127d43efcec83b3b67d2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the elements from <em>iterable</em>, followed by <em>fillvalue</em>, such that at least <em>n</em> items are emitted.  <br /></td></tr>
<tr class="separator:a50adbaec19127d43efcec83b3b67d2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5425f753dfd8559de42b9fc12c28fc2" id="r_aa5425f753dfd8559de42b9fc12c28fc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5425f753dfd8559de42b9fc12c28fc2">repeat_last</a> (iterable, default=None)</td></tr>
<tr class="memdesc:aa5425f753dfd8559de42b9fc12c28fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">After the <em>iterable</em> is exhausted, keep yielding its last element.  <br /></td></tr>
<tr class="separator:aa5425f753dfd8559de42b9fc12c28fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c0a201e6bbd3b1a336c4b775963c6b" id="r_a83c0a201e6bbd3b1a336c4b775963c6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83c0a201e6bbd3b1a336c4b775963c6b">distribute</a> (n, iterable)</td></tr>
<tr class="memdesc:a83c0a201e6bbd3b1a336c4b775963c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute the items from <em>iterable</em> among <em>n</em> smaller iterables.  <br /></td></tr>
<tr class="separator:a83c0a201e6bbd3b1a336c4b775963c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a5061bfeab377fdcb3819d122ea2ae" id="r_aa6a5061bfeab377fdcb3819d122ea2ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6a5061bfeab377fdcb3819d122ea2ae">stagger</a> (iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None)</td></tr>
<tr class="memdesc:aa6a5061bfeab377fdcb3819d122ea2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield tuples whose elements are offset from <em>iterable</em>.  <br /></td></tr>
<tr class="separator:aa6a5061bfeab377fdcb3819d122ea2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e20e24eacb1c2dfe200269764b32ff" id="r_a42e20e24eacb1c2dfe200269764b32ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42e20e24eacb1c2dfe200269764b32ff">_zip_equal_generator</a> (iterables)</td></tr>
<tr class="separator:a42e20e24eacb1c2dfe200269764b32ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310cdb228065a896661fdb3af5198990" id="r_a310cdb228065a896661fdb3af5198990"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a310cdb228065a896661fdb3af5198990">zip_equal</a> (*iterables)</td></tr>
<tr class="memdesc:a310cdb228065a896661fdb3af5198990"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>zip</code> the input <em>iterables</em> together, but raise <code>UnequalIterablesError</code> if they aren't all the same length.  <br /></td></tr>
<tr class="separator:a310cdb228065a896661fdb3af5198990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2e4bfc8d9d82c7daaa81730f316ae4" id="r_a5b2e4bfc8d9d82c7daaa81730f316ae4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b2e4bfc8d9d82c7daaa81730f316ae4">zip_offset</a> (*iterables, offsets, longest=False, fillvalue=None)</td></tr>
<tr class="memdesc:a5b2e4bfc8d9d82c7daaa81730f316ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>zip</code> the input <em>iterables</em> together, but offset the <code>i</code>-th iterable by the <code>i</code>-th item in <em>offsets</em>.  <br /></td></tr>
<tr class="separator:a5b2e4bfc8d9d82c7daaa81730f316ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9b12c4b7074c419c909ee5b3b0b8cf" id="r_aea9b12c4b7074c419c909ee5b3b0b8cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea9b12c4b7074c419c909ee5b3b0b8cf">sort_together</a> (iterables, key_list=(0,), key=None, reverse=False)</td></tr>
<tr class="memdesc:aea9b12c4b7074c419c909ee5b3b0b8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the input iterables sorted together, with <em>key_list</em> as the priority for sorting.  <br /></td></tr>
<tr class="separator:aea9b12c4b7074c419c909ee5b3b0b8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32eebc9faf562f56d169cb5aec787b6d" id="r_a32eebc9faf562f56d169cb5aec787b6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32eebc9faf562f56d169cb5aec787b6d">unzip</a> (iterable)</td></tr>
<tr class="memdesc:a32eebc9faf562f56d169cb5aec787b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of :func:<code>zip</code>, this function disaggregates the elements of the zipped <em>iterable</em>.  <br /></td></tr>
<tr class="separator:a32eebc9faf562f56d169cb5aec787b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db1c5b2b6da960a1ab63de218124d0f" id="r_a4db1c5b2b6da960a1ab63de218124d0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4db1c5b2b6da960a1ab63de218124d0f">divide</a> (n, iterable)</td></tr>
<tr class="memdesc:a4db1c5b2b6da960a1ab63de218124d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the elements from <em>iterable</em> into <em>n</em> parts, maintaining order.  <br /></td></tr>
<tr class="separator:a4db1c5b2b6da960a1ab63de218124d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747a961c026ef4e048dbad7872b7e9ba" id="r_a747a961c026ef4e048dbad7872b7e9ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a747a961c026ef4e048dbad7872b7e9ba">always_iterable</a> (obj, base_type=(str, bytes))</td></tr>
<tr class="memdesc:a747a961c026ef4e048dbad7872b7e9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <em>obj</em> is iterable, return an iterator over its items::  <br /></td></tr>
<tr class="separator:a747a961c026ef4e048dbad7872b7e9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835dca721e46dea810ffe00b70252e86" id="r_a835dca721e46dea810ffe00b70252e86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a835dca721e46dea810ffe00b70252e86">adjacent</a> (predicate, iterable, distance=1)</td></tr>
<tr class="memdesc:a835dca721e46dea810ffe00b70252e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterable over <code>(bool, item)</code> tuples where the <code>item</code> is drawn from <em>iterable</em> and the <code>bool</code> indicates whether that item satisfies the <em>predicate</em> or is adjacent to an item that does.  <br /></td></tr>
<tr class="separator:a835dca721e46dea810ffe00b70252e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26be38b59e90b14984ed58d3b3bbc82" id="r_ab26be38b59e90b14984ed58d3b3bbc82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab26be38b59e90b14984ed58d3b3bbc82">groupby_transform</a> (iterable, keyfunc=None, valuefunc=None, reducefunc=None)</td></tr>
<tr class="memdesc:ab26be38b59e90b14984ed58d3b3bbc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">An extension of :func:<code>itertools.groupby</code> that can apply transformations to the grouped data.  <br /></td></tr>
<tr class="separator:ab26be38b59e90b14984ed58d3b3bbc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad742cc24dfb3b49a4f07db2aa012b8" id="r_a3ad742cc24dfb3b49a4f07db2aa012b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ad742cc24dfb3b49a4f07db2aa012b8">count_cycle</a> (iterable, n=None)</td></tr>
<tr class="memdesc:a3ad742cc24dfb3b49a4f07db2aa012b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycle through the items from <em>iterable</em> up to <em>n</em> times, yielding the number of completed cycles along with each item.  <br /></td></tr>
<tr class="separator:a3ad742cc24dfb3b49a4f07db2aa012b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887baec1ac1113ad302338e44bef29e7" id="r_a887baec1ac1113ad302338e44bef29e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a887baec1ac1113ad302338e44bef29e7">mark_ends</a> (iterable)</td></tr>
<tr class="memdesc:a887baec1ac1113ad302338e44bef29e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield 3-tuples of the form <code>(is_first, is_last, item)</code>.  <br /></td></tr>
<tr class="separator:a887baec1ac1113ad302338e44bef29e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e18ee5ccec970465321f705ee1e11b" id="r_a05e18ee5ccec970465321f705ee1e11b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05e18ee5ccec970465321f705ee1e11b">locate</a> (iterable, pred=bool, window_size=None)</td></tr>
<tr class="memdesc:a05e18ee5ccec970465321f705ee1e11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the index of each item in <em>iterable</em> for which <em>pred</em> returns <code>True</code>.  <br /></td></tr>
<tr class="separator:a05e18ee5ccec970465321f705ee1e11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0712cc8a0f49172287bf947e453677" id="r_a2b0712cc8a0f49172287bf947e453677"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b0712cc8a0f49172287bf947e453677">lstrip</a> (iterable, pred)</td></tr>
<tr class="memdesc:a2b0712cc8a0f49172287bf947e453677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the items from <em>iterable</em>, but strip any from the beginning for which <em>pred</em> returns <code>True</code>.  <br /></td></tr>
<tr class="separator:a2b0712cc8a0f49172287bf947e453677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafac6a26effb97d5579c5412d30bc77" id="r_abafac6a26effb97d5579c5412d30bc77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abafac6a26effb97d5579c5412d30bc77">rstrip</a> (iterable, pred)</td></tr>
<tr class="memdesc:abafac6a26effb97d5579c5412d30bc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the items from <em>iterable</em>, but strip any from the end for which <em>pred</em> returns <code>True</code>.  <br /></td></tr>
<tr class="separator:abafac6a26effb97d5579c5412d30bc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aacddd1fb6d2525e7ca741424fd0045" id="r_a4aacddd1fb6d2525e7ca741424fd0045"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aacddd1fb6d2525e7ca741424fd0045">strip</a> (iterable, pred)</td></tr>
<tr class="memdesc:a4aacddd1fb6d2525e7ca741424fd0045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the items from <em>iterable</em>, but strip any from the beginning and end for which <em>pred</em> returns <code>True</code>.  <br /></td></tr>
<tr class="separator:a4aacddd1fb6d2525e7ca741424fd0045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95249a3c504f20ba7aa1a05dfcbf80b7" id="r_a95249a3c504f20ba7aa1a05dfcbf80b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95249a3c504f20ba7aa1a05dfcbf80b7">_islice_helper</a> (it, s)</td></tr>
<tr class="separator:a95249a3c504f20ba7aa1a05dfcbf80b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed7891e30021a8924131411039ad76a" id="r_a4ed7891e30021a8924131411039ad76a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ed7891e30021a8924131411039ad76a">always_reversible</a> (iterable)</td></tr>
<tr class="memdesc:a4ed7891e30021a8924131411039ad76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An extension of :func:<code>reversed</code> that supports all iterables, not just those which implement the <code>Reversible</code> or <code>Sequence</code> protocols.  <br /></td></tr>
<tr class="separator:a4ed7891e30021a8924131411039ad76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42cfd133811f127a2c4321d8c63042b" id="r_ad42cfd133811f127a2c4321d8c63042b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad42cfd133811f127a2c4321d8c63042b">consecutive_groups</a> (iterable, ordering=lambda x:x)</td></tr>
<tr class="memdesc:ad42cfd133811f127a2c4321d8c63042b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield groups of consecutive items using :func:<code>itertools.groupby</code>.  <br /></td></tr>
<tr class="separator:ad42cfd133811f127a2c4321d8c63042b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e95112d6bab64bd6e57ae7690be37f" id="r_aa1e95112d6bab64bd6e57ae7690be37f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1e95112d6bab64bd6e57ae7690be37f">difference</a> (iterable, func=sub, *initial=None)</td></tr>
<tr class="memdesc:aa1e95112d6bab64bd6e57ae7690be37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the inverse of :func:<code>itertools.accumulate</code>.  <br /></td></tr>
<tr class="separator:aa1e95112d6bab64bd6e57ae7690be37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9a2af8ed9c6a97fc0d47f59ab8dd52" id="r_a9d9a2af8ed9c6a97fc0d47f59ab8dd52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d9a2af8ed9c6a97fc0d47f59ab8dd52">exactly_n</a> (iterable, n, predicate=bool)</td></tr>
<tr class="memdesc:a9d9a2af8ed9c6a97fc0d47f59ab8dd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>True</code> if exactly <code>n</code> items in the iterable are <code>True</code> according to the <em>predicate</em> function.  <br /></td></tr>
<tr class="separator:a9d9a2af8ed9c6a97fc0d47f59ab8dd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affed850f38028aaebb5989efe884862a" id="r_affed850f38028aaebb5989efe884862a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affed850f38028aaebb5989efe884862a">circular_shifts</a> (iterable)</td></tr>
<tr class="memdesc:affed850f38028aaebb5989efe884862a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of circular shifts of <em>iterable</em>.  <br /></td></tr>
<tr class="separator:affed850f38028aaebb5989efe884862a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e8616c9a2d21c6b3b81e351225bf60" id="r_a21e8616c9a2d21c6b3b81e351225bf60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21e8616c9a2d21c6b3b81e351225bf60">make_decorator</a> (wrapping_func, result_index=0)</td></tr>
<tr class="memdesc:a21e8616c9a2d21c6b3b81e351225bf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a decorator version of <em>wrapping_func</em>, which is a function that modifies an iterable.  <br /></td></tr>
<tr class="separator:a21e8616c9a2d21c6b3b81e351225bf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c533b865a3514e16c54991daba7af2" id="r_a45c533b865a3514e16c54991daba7af2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45c533b865a3514e16c54991daba7af2">map_reduce</a> (iterable, keyfunc, valuefunc=None, reducefunc=None)</td></tr>
<tr class="memdesc:a45c533b865a3514e16c54991daba7af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a dictionary that maps the items in <em>iterable</em> to categories defined by <em>keyfunc</em>, transforms them with <em>valuefunc</em>, and then summarizes them by category with <em>reducefunc</em>.  <br /></td></tr>
<tr class="separator:a45c533b865a3514e16c54991daba7af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f682ab11fa2bc3a54def3f13ae20d9" id="r_a31f682ab11fa2bc3a54def3f13ae20d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31f682ab11fa2bc3a54def3f13ae20d9">rlocate</a> (iterable, pred=bool, window_size=None)</td></tr>
<tr class="memdesc:a31f682ab11fa2bc3a54def3f13ae20d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the index of each item in <em>iterable</em> for which <em>pred</em> returns <code>True</code>, starting from the right and moving left.  <br /></td></tr>
<tr class="separator:a31f682ab11fa2bc3a54def3f13ae20d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8daa550cec9c16c67c4500228d1e08d" id="r_ab8daa550cec9c16c67c4500228d1e08d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8daa550cec9c16c67c4500228d1e08d">replace</a> (iterable, pred, substitutes, count=None, window_size=1)</td></tr>
<tr class="memdesc:ab8daa550cec9c16c67c4500228d1e08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the items from <em>iterable</em>, replacing the items for which <em>pred</em> returns <code>True</code> with the items from the iterable <em>substitutes</em>.  <br /></td></tr>
<tr class="separator:ab8daa550cec9c16c67c4500228d1e08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ac8728632c6d80de2b0e3f627b1b77" id="r_a50ac8728632c6d80de2b0e3f627b1b77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50ac8728632c6d80de2b0e3f627b1b77">partitions</a> (iterable)</td></tr>
<tr class="memdesc:a50ac8728632c6d80de2b0e3f627b1b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield all possible order-preserving partitions of <em>iterable</em>.  <br /></td></tr>
<tr class="separator:a50ac8728632c6d80de2b0e3f627b1b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09aba9fcbb4adacab1fdac7c921e39b0" id="r_a09aba9fcbb4adacab1fdac7c921e39b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09aba9fcbb4adacab1fdac7c921e39b0">set_partitions</a> (iterable, k=None)</td></tr>
<tr class="memdesc:a09aba9fcbb4adacab1fdac7c921e39b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the set partitions of <em>iterable</em> into <em>k</em> parts.  <br /></td></tr>
<tr class="separator:a09aba9fcbb4adacab1fdac7c921e39b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f27ecbe9378a7e871e33d55a980ebc7" id="r_a6f27ecbe9378a7e871e33d55a980ebc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f27ecbe9378a7e871e33d55a980ebc7">only</a> (iterable, default=None, too_long=None)</td></tr>
<tr class="memdesc:a6f27ecbe9378a7e871e33d55a980ebc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <em>iterable</em> has only one item, return it.  <br /></td></tr>
<tr class="separator:a6f27ecbe9378a7e871e33d55a980ebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c641087a4891d3ac5b40616a3394bd5" id="r_a9c641087a4891d3ac5b40616a3394bd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c641087a4891d3ac5b40616a3394bd5">ichunked</a> (iterable, n)</td></tr>
<tr class="memdesc:a9c641087a4891d3ac5b40616a3394bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break <em>iterable</em> into sub-iterables with <em>n</em> elements each.  <br /></td></tr>
<tr class="separator:a9c641087a4891d3ac5b40616a3394bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf4eef1c3957d30770055397f1b10ef" id="r_aecf4eef1c3957d30770055397f1b10ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecf4eef1c3957d30770055397f1b10ef">distinct_combinations</a> (iterable, r)</td></tr>
<tr class="memdesc:aecf4eef1c3957d30770055397f1b10ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the distinct combinations of <em>r</em> items taken from <em>iterable</em>.  <br /></td></tr>
<tr class="separator:aecf4eef1c3957d30770055397f1b10ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cf15114e78cfa3671c3635f0e07826" id="r_a75cf15114e78cfa3671c3635f0e07826"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75cf15114e78cfa3671c3635f0e07826">filter_except</a> (validator, iterable, *exceptions)</td></tr>
<tr class="memdesc:a75cf15114e78cfa3671c3635f0e07826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the items from <em>iterable</em> for which the <em>validator</em> function does not raise one of the specified <em>exceptions</em>.  <br /></td></tr>
<tr class="separator:a75cf15114e78cfa3671c3635f0e07826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f31c6152daaffa29cd357b6080416f" id="r_af5f31c6152daaffa29cd357b6080416f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5f31c6152daaffa29cd357b6080416f">map_except</a> (function, iterable, *exceptions)</td></tr>
<tr class="memdesc:af5f31c6152daaffa29cd357b6080416f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform each item from <em>iterable</em> with <em>function</em> and yield the result, unless <em>function</em> raises one of the specified <em>exceptions</em>.  <br /></td></tr>
<tr class="separator:af5f31c6152daaffa29cd357b6080416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d30cb28efe1b2b0e586aee21b16368b" id="r_a0d30cb28efe1b2b0e586aee21b16368b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d30cb28efe1b2b0e586aee21b16368b">_sample_unweighted</a> (iterable, k)</td></tr>
<tr class="separator:a0d30cb28efe1b2b0e586aee21b16368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec7ac4b35d3e11e81091ab5cd00017e" id="r_a4ec7ac4b35d3e11e81091ab5cd00017e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ec7ac4b35d3e11e81091ab5cd00017e">_sample_weighted</a> (iterable, k, weights)</td></tr>
<tr class="separator:a4ec7ac4b35d3e11e81091ab5cd00017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1405cfbac3f502521faf280895b1920a" id="r_a1405cfbac3f502521faf280895b1920a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1405cfbac3f502521faf280895b1920a">sample</a> (iterable, k, weights=None)</td></tr>
<tr class="memdesc:a1405cfbac3f502521faf280895b1920a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <em>k</em>-length list of elements chosen (without replacement) from the <em>iterable</em>.  <br /></td></tr>
<tr class="separator:a1405cfbac3f502521faf280895b1920a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cbbbf641f0a69938658857aacd4a4b" id="r_a81cbbbf641f0a69938658857aacd4a4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81cbbbf641f0a69938658857aacd4a4b">is_sorted</a> (iterable, key=None, reverse=False)</td></tr>
<tr class="memdesc:a81cbbbf641f0a69938658857aacd4a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>True</code> if the items of iterable are in sorted order, and <code>False</code> otherwise.  <br /></td></tr>
<tr class="separator:a81cbbbf641f0a69938658857aacd4a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c0440945239e801c6cb8025ab068c9" id="r_a02c0440945239e801c6cb8025ab068c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02c0440945239e801c6cb8025ab068c9">windowed_complete</a> (iterable, n)</td></tr>
<tr class="memdesc:a02c0440945239e801c6cb8025ab068c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield <code>(beginning, middle, end)</code> tuples, where:  <br /></td></tr>
<tr class="separator:a02c0440945239e801c6cb8025ab068c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b736b170fbf6c04c61095495941cc9" id="r_a85b736b170fbf6c04c61095495941cc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85b736b170fbf6c04c61095495941cc9">all_unique</a> (iterable, key=None)</td></tr>
<tr class="memdesc:a85b736b170fbf6c04c61095495941cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>True</code> if all the elements of <em>iterable</em> are unique (no two elements are equal).  <br /></td></tr>
<tr class="separator:a85b736b170fbf6c04c61095495941cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3159489420e4a47a301c6d2d9c0529" id="r_a0b3159489420e4a47a301c6d2d9c0529"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b3159489420e4a47a301c6d2d9c0529">nth_product</a> (index, *args)</td></tr>
<tr class="memdesc:a0b3159489420e4a47a301c6d2d9c0529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>list(product(*args))[index]</code>.  <br /></td></tr>
<tr class="separator:a0b3159489420e4a47a301c6d2d9c0529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8fb234f6fe28459220bb2acf7e7024" id="r_a1e8fb234f6fe28459220bb2acf7e7024"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e8fb234f6fe28459220bb2acf7e7024">nth_permutation</a> (iterable, r, index)</td></tr>
<tr class="memdesc:a1e8fb234f6fe28459220bb2acf7e7024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>list(permutations(iterable, r))[index]</code>`.  <br /></td></tr>
<tr class="separator:a1e8fb234f6fe28459220bb2acf7e7024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b402e9e076f6d6c1d7d13dccb5d992c" id="r_a0b402e9e076f6d6c1d7d13dccb5d992c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b402e9e076f6d6c1d7d13dccb5d992c">value_chain</a> (*args)</td></tr>
<tr class="memdesc:a0b402e9e076f6d6c1d7d13dccb5d992c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield all arguments passed to the function in the same order in which they were passed.  <br /></td></tr>
<tr class="separator:a0b402e9e076f6d6c1d7d13dccb5d992c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04f1738abb04e3d9334e3daf689c4a5" id="r_ad04f1738abb04e3d9334e3daf689c4a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad04f1738abb04e3d9334e3daf689c4a5">product_index</a> (element, *args)</td></tr>
<tr class="memdesc:ad04f1738abb04e3d9334e3daf689c4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>list(product(*args)).index(element)</code>  <br /></td></tr>
<tr class="separator:ad04f1738abb04e3d9334e3daf689c4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d03eaa373fc38712ee738617d1f0e4" id="r_a60d03eaa373fc38712ee738617d1f0e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60d03eaa373fc38712ee738617d1f0e4">combination_index</a> (element, iterable)</td></tr>
<tr class="memdesc:a60d03eaa373fc38712ee738617d1f0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>list(combinations(iterable, r)).index(element)</code>  <br /></td></tr>
<tr class="separator:a60d03eaa373fc38712ee738617d1f0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a435858b2e240b461187e43423a959" id="r_aa8a435858b2e240b461187e43423a959"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8a435858b2e240b461187e43423a959">permutation_index</a> (element, iterable)</td></tr>
<tr class="memdesc:aa8a435858b2e240b461187e43423a959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>list(permutations(iterable, r)).index(element)</code>`.  <br /></td></tr>
<tr class="separator:aa8a435858b2e240b461187e43423a959"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0031bf1f6cd4f281f6196d58cb31deb1" id="r_a0031bf1f6cd4f281f6196d58cb31deb1"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0031bf1f6cd4f281f6196d58cb31deb1">C</a> :\Users\anupamays\xDPUinfra\xDPUStorageTest\lib\host&gt;doxypypy -a -c &quot;C:/Users/anupamays/xDPUinfra/xDPUStorageTest/venv/Lib/site-packages/setuptools/_vendor/more_itertools/more.py&quot;</td></tr>
<tr class="separator:a0031bf1f6cd4f281f6196d58cb31deb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e7235e60a759a922fdec5a1c512922" id="r_ac9e7235e60a759a922fdec5a1c512922"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9e7235e60a759a922fdec5a1c512922">_marker</a></td></tr>
<tr class="separator:ac9e7235e60a759a922fdec5a1c512922"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a95249a3c504f20ba7aa1a05dfcbf80b7" name="a95249a3c504f20ba7aa1a05dfcbf80b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95249a3c504f20ba7aa1a05dfcbf80b7">&#9670;&#160;</a></span>_islice_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more._islice_helper </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>it</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d30cb28efe1b2b0e586aee21b16368b" name="a0d30cb28efe1b2b0e586aee21b16368b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d30cb28efe1b2b0e586aee21b16368b">&#9670;&#160;</a></span>_sample_unweighted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more._sample_unweighted </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ec7ac4b35d3e11e81091ab5cd00017e" name="a4ec7ac4b35d3e11e81091ab5cd00017e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec7ac4b35d3e11e81091ab5cd00017e">&#9670;&#160;</a></span>_sample_weighted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more._sample_weighted </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>weights</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42e20e24eacb1c2dfe200269764b32ff" name="a42e20e24eacb1c2dfe200269764b32ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e20e24eacb1c2dfe200269764b32ff">&#9670;&#160;</a></span>_zip_equal_generator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more._zip_equal_generator </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterables</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a835dca721e46dea810ffe00b70252e86" name="a835dca721e46dea810ffe00b70252e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835dca721e46dea810ffe00b70252e86">&#9670;&#160;</a></span>adjacent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.adjacent </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>predicate</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>distance</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an iterable over <code>(bool, item)</code> tuples where the <code>item</code> is drawn from <em>iterable</em> and the <code>bool</code> indicates whether that item satisfies the <em>predicate</em> or is adjacent to an item that does. </p>
<p>For example, to find whether items are adjacent to a <code>3</code>::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(adjacent(<span class="keyword">lambda</span> x: x == 3, range(6)))</div>
<div class="line">[(<span class="keyword">False</span>, 0), (<span class="keyword">False</span>, 1), (<span class="keyword">True</span>, 2), (<span class="keyword">True</span>, 3), (<span class="keyword">True</span>, 4), (<span class="keyword">False</span>, 5)]</div>
</div><!-- fragment --><p> Set <em>distance</em> to change what counts as adjacent. For example, to find whether items are two places away from a <code>3</code>:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(adjacent(<span class="keyword">lambda</span> x: x == 3, range(6), distance=2))</div>
<div class="line">[(<span class="keyword">False</span>, 0), (<span class="keyword">True</span>, 1), (<span class="keyword">True</span>, 2), (<span class="keyword">True</span>, 3), (<span class="keyword">True</span>, 4), (<span class="keyword">True</span>, 5)]</div>
</div><!-- fragment --><p> This is useful for contextualizing the results of a search function. For example, a code comparison tool might want to identify lines that have changed, but also surrounding lines to give the viewer of the diff context.</p>
<p>The predicate function will only be called once for each item in the iterable.</p>
<p>See also :func:<code>groupby_transform</code>, which can be used with this function to group ranges of items with the same <code>bool</code> value. </p>

</div>
</div>
<a id="a85b736b170fbf6c04c61095495941cc9" name="a85b736b170fbf6c04c61095495941cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b736b170fbf6c04c61095495941cc9">&#9670;&#160;</a></span>all_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.all_unique </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>key</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>True</code> if all the elements of <em>iterable</em> are unique (no two elements are equal). </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; all_unique(<span class="stringliteral">&#39;ABCB&#39;</span>)</div>
<div class="line"><span class="keyword">False</span></div>
</div><!-- fragment --><p> If a <em>key</em> function is specified, it will be used to make comparisons.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; all_unique(<span class="stringliteral">&#39;ABCb&#39;</span>)</div>
<div class="line"><span class="keyword">True</span></div>
<div class="line">&gt;&gt;&gt; all_unique(<span class="stringliteral">&#39;ABCb&#39;</span>, str.lower)</div>
<div class="line"><span class="keyword">False</span></div>
</div><!-- fragment --><p> The function returns as soon as the first non-unique element is encountered. Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items. </p>

</div>
</div>
<a id="a747a961c026ef4e048dbad7872b7e9ba" name="a747a961c026ef4e048dbad7872b7e9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747a961c026ef4e048dbad7872b7e9ba">&#9670;&#160;</a></span>always_iterable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.always_iterable </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>obj</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>base_type</em><span class="paramdefsep"> = </span><span class="paramdefval">(str,&#160;bytes)</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <em>obj</em> is iterable, return an iterator over its items:: </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; obj = (1, 2, 3)</div>
<div class="line">&gt;&gt;&gt; list(always_iterable(obj))</div>
<div class="line">[1, 2, 3]</div>
</div><!-- fragment --><p> If <em>obj</em> is not iterable, return a one-item iterable containing <em>obj</em>::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; obj = 1</div>
<div class="line">&gt;&gt;&gt; list(always_iterable(obj))</div>
<div class="line">[1]</div>
</div><!-- fragment --><p> If <em>obj</em> is <code>None</code>, return an empty iterable:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; obj = <span class="keywordtype">None</span></div>
<div class="line">&gt;&gt;&gt; list(always_iterable(<span class="keywordtype">None</span>))</div>
<div class="line">[]</div>
</div><!-- fragment --><p> By default, binary and text strings are not considered iterable::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; obj = <span class="stringliteral">&#39;foo&#39;</span></div>
<div class="line">&gt;&gt;&gt; list(always_iterable(obj))</div>
<div class="line">[<span class="stringliteral">&#39;foo&#39;</span>]</div>
</div><!-- fragment --><p> If <em>base_type</em> is set, objects for which <code>isinstance(obj, base_type)</code> returns <code>True</code> won't be considered iterable.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; obj = {<span class="stringliteral">&#39;a&#39;</span>: 1}</div>
<div class="line">&gt;&gt;&gt; list(always_iterable(obj))  <span class="comment"># Iterate over the dict&#39;s keys</span></div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>]</div>
<div class="line">&gt;&gt;&gt; list(always_iterable(obj, base_type=dict))  <span class="comment"># Treat dicts as a unit</span></div>
<div class="line">[{<span class="stringliteral">&#39;a&#39;</span>: 1}]</div>
</div><!-- fragment --><p> Set <em>base_type</em> to <code>None</code> to avoid any special handling and treat objects Python considers iterable as iterable:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; obj = <span class="stringliteral">&#39;foo&#39;</span></div>
<div class="line">&gt;&gt;&gt; list(always_iterable(obj, base_type=<span class="keywordtype">None</span>))</div>
<div class="line">[<span class="stringliteral">&#39;f&#39;</span>, <span class="stringliteral">&#39;o&#39;</span>, <span class="stringliteral">&#39;o&#39;</span>]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4ed7891e30021a8924131411039ad76a" name="a4ed7891e30021a8924131411039ad76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed7891e30021a8924131411039ad76a">&#9670;&#160;</a></span>always_reversible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.always_reversible </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An extension of :func:<code>reversed</code> that supports all iterables, not just those which implement the <code>Reversible</code> or <code>Sequence</code> protocols. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; print(*always_reversible(x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> range(3)))</div>
</div><!-- fragment --><p> 2 1 0</p>
<p>If the iterable is already reversible, this function returns the result of :func:<code>reversed()</code>. If the iterable is not reversible, this function will cache the remaining items in the iterable and yield them in reverse order, which may require significant storage. </p>

</div>
</div>
<a id="abffb53abf1266b52e612759e97a93b4d" name="abffb53abf1266b52e612759e97a93b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffb53abf1266b52e612759e97a93b4d">&#9670;&#160;</a></span>chunked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.chunked </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">False</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Break <em>iterable</em> into lists of length <em>n</em>: </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(chunked([1, 2, 3, 4, 5, 6], 3))</div>
<div class="line">[[1, 2, 3], [4, 5, 6]]</div>
</div><!-- fragment --><p> By the default, the last yielded list will have fewer than <em>n</em> elements if the length of <em>iterable</em> is not divisible by <em>n</em>:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))</div>
<div class="line">[[1, 2, 3], [4, 5, 6], [7, 8]]</div>
</div><!-- fragment --><p> To use a fill-in value instead, see the :func:<code>grouper</code> recipe.</p>
<p>If the length of <em>iterable</em> is not divisible by <em>n</em> and <em>strict</em> is <code>True</code>, then <code>ValueError</code> will be raised before the last list is yielded. </p>

</div>
</div>
<a id="affed850f38028aaebb5989efe884862a" name="affed850f38028aaebb5989efe884862a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affed850f38028aaebb5989efe884862a">&#9670;&#160;</a></span>circular_shifts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.circular_shifts </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of circular shifts of <em>iterable</em>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; circular_shifts(range(4))</div>
<div class="line">[(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad41738788dce77084e613575a9391382" name="ad41738788dce77084e613575a9391382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41738788dce77084e613575a9391382">&#9670;&#160;</a></span>collapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.collapse </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>base_type</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>levels</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten an iterable with multiple levels of nesting (e.g., a list of lists of tuples) into non-iterable types. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [(1, 2), ([3, 4], [[5], [6]])]</div>
<div class="line">&gt;&gt;&gt; list(collapse(iterable))</div>
<div class="line">[1, 2, 3, 4, 5, 6]</div>
</div><!-- fragment --><p> Binary and text strings are not considered iterable and will not be collapsed.</p>
<p>To avoid collapsing other types, specify <em>base_type</em>:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [<span class="stringliteral">&#39;ab&#39;</span>, (<span class="stringliteral">&#39;cd&#39;</span>, <span class="stringliteral">&#39;ef&#39;</span>), [<span class="stringliteral">&#39;gh&#39;</span>, <span class="stringliteral">&#39;ij&#39;</span>]]</div>
<div class="line">&gt;&gt;&gt; list(collapse(iterable, base_type=tuple))</div>
<div class="line">[<span class="stringliteral">&#39;ab&#39;</span>, (<span class="stringliteral">&#39;cd&#39;</span>, <span class="stringliteral">&#39;ef&#39;</span>), <span class="stringliteral">&#39;gh&#39;</span>, <span class="stringliteral">&#39;ij&#39;</span>]</div>
</div><!-- fragment --><p> Specify <em>levels</em> to stop flattening after a certain level:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [(<span class="stringliteral">&#39;a&#39;</span>, [<span class="stringliteral">&#39;b&#39;</span>]), (<span class="stringliteral">&#39;c&#39;</span>, [<span class="stringliteral">&#39;d&#39;</span>])]</div>
<div class="line">&gt;&gt;&gt; list(collapse(iterable))  <span class="comment"># Fully flattened</span></div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;d&#39;</span>]</div>
<div class="line">&gt;&gt;&gt; list(collapse(iterable, levels=1))  <span class="comment"># Only one level flattened</span></div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>, [<span class="stringliteral">&#39;b&#39;</span>], <span class="stringliteral">&#39;c&#39;</span>, [<span class="stringliteral">&#39;d&#39;</span>]]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a691dc99d522ad3defe468a1ee9bd532d" name="a691dc99d522ad3defe468a1ee9bd532d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691dc99d522ad3defe468a1ee9bd532d">&#9670;&#160;</a></span>collate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.collate </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>iterables</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a sorted merge of the items from each of several already-sorted <em>iterables</em>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(collate(<span class="stringliteral">&#39;ACDZ&#39;</span>, <span class="stringliteral">&#39;AZ&#39;</span>, <span class="stringliteral">&#39;JKL&#39;</span>))</div>
<div class="line">[<span class="stringliteral">&#39;A&#39;</span>, <span class="stringliteral">&#39;A&#39;</span>, <span class="stringliteral">&#39;C&#39;</span>, <span class="stringliteral">&#39;D&#39;</span>, <span class="stringliteral">&#39;J&#39;</span>, <span class="stringliteral">&#39;K&#39;</span>, <span class="stringliteral">&#39;L&#39;</span>, <span class="stringliteral">&#39;Z&#39;</span>, <span class="stringliteral">&#39;Z&#39;</span>]</div>
</div><!-- fragment --><p> Works lazily, keeping only the next value from each iterable in memory. Use :func:<code>collate</code> to, for example, perform a n-way mergesort of items that don't fit in memory.</p>
<p>If a <em>key</em> function is specified, the iterables will be sorted according to its result:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; key = <span class="keyword">lambda</span> s: int(s)  <span class="comment"># Sort by numeric value, not by string</span></div>
<div class="line">&gt;&gt;&gt; list(collate([<span class="stringliteral">&#39;1&#39;</span>, <span class="stringliteral">&#39;10&#39;</span>], [<span class="stringliteral">&#39;2&#39;</span>, <span class="stringliteral">&#39;11&#39;</span>], key=key))</div>
<div class="line">[<span class="stringliteral">&#39;1&#39;</span>, <span class="stringliteral">&#39;2&#39;</span>, <span class="stringliteral">&#39;10&#39;</span>, <span class="stringliteral">&#39;11&#39;</span>]</div>
</div><!-- fragment --><p> If the <em>iterables</em> are sorted in descending order, set <em>reverse</em> to <code>True</code>:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(collate([5, 3, 1], [4, 2, 0], reverse=<span class="keyword">True</span>))</div>
<div class="line">[5, 4, 3, 2, 1, 0]</div>
</div><!-- fragment --><p> If the elements of the passed-in iterables are out of order, you might get unexpected results.</p>
<p>On Python 3.5+, this function is an alias for :func:<code>heapq.merge</code>. </p>

</div>
</div>
<a id="a60d03eaa373fc38712ee738617d1f0e4" name="a60d03eaa373fc38712ee738617d1f0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d03eaa373fc38712ee738617d1f0e4">&#9670;&#160;</a></span>combination_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.combination_index </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>element</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>list(combinations(iterable, r)).index(element)</code> </p>
<p>The subsequences of <em>iterable</em> that are of length <em>r</em> can be ordered lexicographically. :func:<code>combination_index</code> computes the index of the first <em>element</em>, without computing the previous combinations.</p>
<div class="fragment"><div class="line">    &gt;&gt;&gt; combination_index(<span class="stringliteral">&#39;adf&#39;</span>, <span class="stringliteral">&#39;abcdefg&#39;</span>)</div>
<div class="line">    10</div>
<div class="line"> </div>
<div class="line">``ValueError`` will be raised <span class="keywordflow">if</span> the given *element* isn<span class="stringliteral">&#39;t one of the</span></div>
</div><!-- fragment --><p> combinations of <em>iterable</em>. </p>

</div>
</div>
<a id="ad42cfd133811f127a2c4321d8c63042b" name="ad42cfd133811f127a2c4321d8c63042b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42cfd133811f127a2c4321d8c63042b">&#9670;&#160;</a></span>consecutive_groups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.consecutive_groups </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ordering</em><span class="paramdefsep"> = </span><span class="paramdefval">lambda&#160;x:&#160;x</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield groups of consecutive items using :func:<code>itertools.groupby</code>. </p>
<p>The <em>ordering</em> function determines whether two items are adjacent by returning their position.</p>
<p>By default, the ordering function is the identity function. This is suitable for finding runs of numbers:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]</div>
<div class="line">&gt;&gt;&gt; <span class="keywordflow">for</span> group <span class="keywordflow">in</span> consecutive_groups(iterable):</div>
<div class="line">...     print(list(group))</div>
<div class="line">[1]</div>
<div class="line">[10, 11, 12]</div>
<div class="line">[20]</div>
<div class="line">[30, 31, 32, 33]</div>
<div class="line">[40]</div>
</div><!-- fragment --><p> For finding runs of adjacent letters, try using the :meth:<code>index</code> method of a string of letters:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">from</span> string <span class="keyword">import</span> ascii_lowercase</div>
<div class="line">&gt;&gt;&gt; iterable = <span class="stringliteral">&#39;abcdfgilmnop&#39;</span></div>
<div class="line">&gt;&gt;&gt; ordering = ascii_lowercase.index</div>
<div class="line">&gt;&gt;&gt; <span class="keywordflow">for</span> group <span class="keywordflow">in</span> consecutive_groups(iterable, ordering):</div>
<div class="line">...     print(list(group))</div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;d&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;f&#39;</span>, <span class="stringliteral">&#39;g&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;i&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;l&#39;</span>, <span class="stringliteral">&#39;m&#39;</span>, <span class="stringliteral">&#39;n&#39;</span>, <span class="stringliteral">&#39;o&#39;</span>, <span class="stringliteral">&#39;p&#39;</span>]</div>
</div><!-- fragment --><p> Each group of consecutive items is an iterator that shares it source with <em>iterable</em>. When an an output group is advanced, the previous group is no longer available unless its elements are copied (e.g., into a <code>list</code>).</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [1, 2, 11, 12, 21, 22]</div>
<div class="line">&gt;&gt;&gt; saved_groups = []</div>
<div class="line">&gt;&gt;&gt; <span class="keywordflow">for</span> group <span class="keywordflow">in</span> consecutive_groups(iterable):</div>
<div class="line">...     saved_groups.append(list(group))  <span class="comment"># Copy group elements</span></div>
<div class="line">&gt;&gt;&gt; saved_groups</div>
<div class="line">[[1, 2], [11, 12], [21, 22]]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a227e66c12cc86c45187adb224fee478b" name="a227e66c12cc86c45187adb224fee478b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227e66c12cc86c45187adb224fee478b">&#9670;&#160;</a></span>consumer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.consumer </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorator that automatically advances a PEP-342-style "reverse iterator" to its first yield point so you don't have to call <code>next()</code> on it manually. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="preprocessor">@consumer</span></div>
<div class="line">... <span class="keyword">def </span>tally():</div>
<div class="line">...     i = 0</div>
<div class="line">...     <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">...         print(<span class="stringliteral">&#39;Thing number %s is %s.&#39;</span> % (i, (<span class="keywordflow">yield</span>)))</div>
<div class="line">...         i += 1</div>
<div class="line">...</div>
<div class="line">&gt;&gt;&gt; t = tally()</div>
<div class="line">&gt;&gt;&gt; t.send(<span class="stringliteral">&#39;red&#39;</span>)</div>
</div><!-- fragment --><p> Thing number 0 is red. </p><div class="fragment"><div class="line">&gt;&gt;&gt; t.send(<span class="stringliteral">&#39;fish&#39;</span>)</div>
</div><!-- fragment --><p> Thing number 1 is fish.</p>
<p>Without the decorator, you would have to call <code>next(t)</code> before <code>t.send()</code> could be used. </p>

</div>
</div>
<a id="a3ad742cc24dfb3b49a4f07db2aa012b8" name="a3ad742cc24dfb3b49a4f07db2aa012b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad742cc24dfb3b49a4f07db2aa012b8">&#9670;&#160;</a></span>count_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.count_cycle </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cycle through the items from <em>iterable</em> up to <em>n</em> times, yielding the number of completed cycles along with each item. </p>
<p>If <em>n</em> is omitted the process repeats indefinitely.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(count_cycle(<span class="stringliteral">&#39;AB&#39;</span>, 3))</div>
<div class="line">[(0, <span class="stringliteral">&#39;A&#39;</span>), (0, <span class="stringliteral">&#39;B&#39;</span>), (1, <span class="stringliteral">&#39;A&#39;</span>), (1, <span class="stringliteral">&#39;B&#39;</span>), (2, <span class="stringliteral">&#39;A&#39;</span>), (2, <span class="stringliteral">&#39;B&#39;</span>)]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa1e95112d6bab64bd6e57ae7690be37f" name="aa1e95112d6bab64bd6e57ae7690be37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e95112d6bab64bd6e57ae7690be37f">&#9670;&#160;</a></span>difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.difference </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>func</em><span class="paramdefsep"> = </span><span class="paramdefval">sub</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>initial</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the inverse of :func:<code>itertools.accumulate</code>. </p>
<p>By default it will compute the first difference of <em>iterable</em> using :func:<code>operator.sub</code>:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</div>
<div class="line">&gt;&gt;&gt; iterable = accumulate([0, 1, 2, 3, 4])  <span class="comment"># produces 0, 1, 3, 6, 10</span></div>
<div class="line">&gt;&gt;&gt; list(difference(iterable))</div>
<div class="line">[0, 1, 2, 3, 4]</div>
</div><!-- fragment --><p> <em>func</em> defaults to :func:<code>operator.sub</code>, but other functions can be specified. They will be applied as follows:: </p><pre class="fragment">A, B, C, D, ... --&gt; A, func(B, A), func(C, B), func(D, C), ...
</pre><p> For example, to do progressive division:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [1, 2, 6, 24, 120]</div>
<div class="line">&gt;&gt;&gt; func = <span class="keyword">lambda</span> x, y: x // y</div>
<div class="line">&gt;&gt;&gt; list(difference(iterable, func))</div>
<div class="line">[1, 2, 3, 4, 5]</div>
</div><!-- fragment --><p> If the <em>initial</em> keyword is set, the first element will be skipped when computing successive differences.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; it = [10, 11, 13, 16]  <span class="comment"># from accumulate([1, 2, 3], initial=10)</span></div>
<div class="line">&gt;&gt;&gt; list(difference(it, initial=10))</div>
<div class="line">[1, 2, 3]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aecf4eef1c3957d30770055397f1b10ef" name="aecf4eef1c3957d30770055397f1b10ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf4eef1c3957d30770055397f1b10ef">&#9670;&#160;</a></span>distinct_combinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.distinct_combinations </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the distinct combinations of <em>r</em> items taken from <em>iterable</em>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(distinct_combinations([0, 0, 1], 2))</div>
<div class="line">[(0, 0), (0, 1)]</div>
</div><!-- fragment --><p> Equivalent to <code>set(combinations(iterable))</code>, except duplicates are not generated and thrown away. For larger input sequences this is much more efficient. </p>

</div>
</div>
<a id="ab8491276c50929899fe32cda6fd2d01e" name="ab8491276c50929899fe32cda6fd2d01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8491276c50929899fe32cda6fd2d01e">&#9670;&#160;</a></span>distinct_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.distinct_permutations </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>r</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield successive distinct permutations of the elements in <em>iterable</em>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; sorted(distinct_permutations([1, 0, 1]))</div>
<div class="line">[(0, 1, 1), (1, 0, 1), (1, 1, 0)]</div>
</div><!-- fragment --><p> Equivalent to <code>set(permutations(iterable))</code>, except duplicates are not generated and thrown away. For larger input sequences this is much more efficient.</p>
<p>Duplicate permutations arise when there are duplicated elements in the input iterable. The number of items returned is <code>n! / (x_1! * x_2! * ... * x_n!)</code>, where <code>n</code> is the total number of items input, and each <code>x_i</code> is the count of a distinct item in the input sequence.</p>
<p>If <em>r</em> is given, only the <em>r</em>-length permutations are yielded.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; sorted(distinct_permutations([1, 0, 1], r=2))</div>
<div class="line">[(0, 1), (1, 0), (1, 1)]</div>
<div class="line">&gt;&gt;&gt; sorted(distinct_permutations(range(3), r=2))</div>
<div class="line">[(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a83c0a201e6bbd3b1a336c4b775963c6b" name="a83c0a201e6bbd3b1a336c4b775963c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c0a201e6bbd3b1a336c4b775963c6b">&#9670;&#160;</a></span>distribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.distribute </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distribute the items from <em>iterable</em> among <em>n</em> smaller iterables. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])</div>
<div class="line">&gt;&gt;&gt; list(group_1)</div>
<div class="line">[1, 3, 5]</div>
<div class="line">&gt;&gt;&gt; list(group_2)</div>
<div class="line">[2, 4, 6]</div>
</div><!-- fragment --><p> If the length of <em>iterable</em> is not evenly divisible by <em>n</em>, then the length of the returned iterables will not be identical:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; children = distribute(3, [1, 2, 3, 4, 5, 6, 7])</div>
<div class="line">&gt;&gt;&gt; [list(c) <span class="keywordflow">for</span> c <span class="keywordflow">in</span> children]</div>
<div class="line">[[1, 4, 7], [2, 5], [3, 6]]</div>
</div><!-- fragment --><p> If the length of <em>iterable</em> is smaller than <em>n</em>, then the last returned iterables will be empty:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; children = distribute(5, [1, 2, 3])</div>
<div class="line">&gt;&gt;&gt; [list(c) <span class="keywordflow">for</span> c <span class="keywordflow">in</span> children]</div>
<div class="line">[[1], [2], [3], [], []]</div>
</div><!-- fragment --><p> This function uses :func:<code>itertools.tee</code> and may require significant storage. If you need the order items in the smaller iterables to match the original iterable, see :func:<code>divide</code>. </p>

</div>
</div>
<a id="a4db1c5b2b6da960a1ab63de218124d0f" name="a4db1c5b2b6da960a1ab63de218124d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db1c5b2b6da960a1ab63de218124d0f">&#9670;&#160;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.divide </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide the elements from <em>iterable</em> into <em>n</em> parts, maintaining order. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])</div>
<div class="line">&gt;&gt;&gt; list(group_1)</div>
<div class="line">[1, 2, 3]</div>
<div class="line">&gt;&gt;&gt; list(group_2)</div>
<div class="line">[4, 5, 6]</div>
</div><!-- fragment --><p> If the length of <em>iterable</em> is not evenly divisible by <em>n</em>, then the length of the returned iterables will not be identical:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; children = divide(3, [1, 2, 3, 4, 5, 6, 7])</div>
<div class="line">&gt;&gt;&gt; [list(c) <span class="keywordflow">for</span> c <span class="keywordflow">in</span> children]</div>
<div class="line">[[1, 2, 3], [4, 5], [6, 7]]</div>
</div><!-- fragment --><p> If the length of the iterable is smaller than n, then the last returned iterables will be empty:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; children = divide(5, [1, 2, 3])</div>
<div class="line">&gt;&gt;&gt; [list(c) <span class="keywordflow">for</span> c <span class="keywordflow">in</span> children]</div>
<div class="line">[[1], [2], [3], [], []]</div>
</div><!-- fragment --><p> This function will exhaust the iterable before returning and may require significant storage. If order is not important, see :func:<code>distribute</code>, which does not first pull the iterable into memory. </p>

</div>
</div>
<a id="a9d9a2af8ed9c6a97fc0d47f59ab8dd52" name="a9d9a2af8ed9c6a97fc0d47f59ab8dd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9a2af8ed9c6a97fc0d47f59ab8dd52">&#9670;&#160;</a></span>exactly_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.exactly_n </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>predicate</em><span class="paramdefsep"> = </span><span class="paramdefval">bool</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>True</code> if exactly <code>n</code> items in the iterable are <code>True</code> according to the <em>predicate</em> function. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; exactly_n([<span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">False</span>], 2)</div>
<div class="line"><span class="keyword">True</span></div>
<div class="line">&gt;&gt;&gt; exactly_n([<span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">False</span>], 1)</div>
<div class="line"><span class="keyword">False</span></div>
<div class="line">&gt;&gt;&gt; exactly_n([0, 1, 2, 3, 4, 5], 3, <span class="keyword">lambda</span> x: x &lt; 3)</div>
<div class="line"><span class="keyword">True</span></div>
</div><!-- fragment --><p> The iterable will be advanced until <code>n + 1</code> truthy items are encountered, so avoid calling it on infinite iterables. </p>

</div>
</div>
<a id="a75cf15114e78cfa3671c3635f0e07826" name="a75cf15114e78cfa3671c3635f0e07826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cf15114e78cfa3671c3635f0e07826">&#9670;&#160;</a></span>filter_except()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.filter_except </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>validator</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>exceptions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the items from <em>iterable</em> for which the <em>validator</em> function does not raise one of the specified <em>exceptions</em>. </p>
<p><em>validator</em> is called for each item in <em>iterable</em>. It should be a function that accepts one argument and raises an exception if that item is not valid.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [<span class="stringliteral">&#39;1&#39;</span>, <span class="stringliteral">&#39;2&#39;</span>, <span class="stringliteral">&#39;three&#39;</span>, <span class="stringliteral">&#39;4&#39;</span>, <span class="keywordtype">None</span>]</div>
<div class="line">&gt;&gt;&gt; list(filter_except(int, iterable, ValueError, TypeError))</div>
<div class="line">[<span class="stringliteral">&#39;1&#39;</span>, <span class="stringliteral">&#39;2&#39;</span>, <span class="stringliteral">&#39;4&#39;</span>]</div>
</div><!-- fragment --><p> If an exception other than one given by <em>exceptions</em> is raised by <em>validator</em>, it is raised like normal. </p>

</div>
</div>
<a id="a3d65f68012304f562994508d19d68b4b" name="a3d65f68012304f562994508d19d68b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d65f68012304f562994508d19d68b4b">&#9670;&#160;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.first </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>default</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ac9e7235e60a759a922fdec5a1c512922">_marker</a></span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first item of <em>iterable</em>, or <em>default</em> if <em>iterable</em> is empty. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; first([0, 1, 2, 3])</div>
<div class="line">0</div>
<div class="line">&gt;&gt;&gt; first([], <span class="stringliteral">&#39;some default&#39;</span>)</div>
<div class="line"><span class="stringliteral">&#39;some default&#39;</span></div>
</div><!-- fragment --><p> If <em>default</em> is not provided and there are no items in the iterable, raise <code>ValueError</code>.</p>
<p>:func:<code>first</code> is useful when you have a generator of expensive-to-retrieve values and want any arbitrary one. It is marginally shorter than <code>next(iter(iterable), default)</code>. </p>

</div>
</div>
<a id="ab26be38b59e90b14984ed58d3b3bbc82" name="ab26be38b59e90b14984ed58d3b3bbc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26be38b59e90b14984ed58d3b3bbc82">&#9670;&#160;</a></span>groupby_transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.groupby_transform </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>keyfunc</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>valuefunc</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>reducefunc</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An extension of :func:<code>itertools.groupby</code> that can apply transformations to the grouped data. </p>
<ul>
<li><em>keyfunc</em> is a function computing a key value for each item in <em>iterable</em></li>
<li><em>valuefunc</em> is a function that transforms the individual items from <em>iterable</em> after grouping</li>
<li><em>reducefunc</em> is a function that transforms each group of items</li>
</ul>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = <span class="stringliteral">&#39;aAAbBBcCC&#39;</span></div>
<div class="line">&gt;&gt;&gt; keyfunc = <span class="keyword">lambda</span> k: k.upper()</div>
<div class="line">&gt;&gt;&gt; valuefunc = <span class="keyword">lambda</span> v: v.lower()</div>
<div class="line">&gt;&gt;&gt; reducefunc = <span class="keyword">lambda</span> g: <span class="stringliteral">&#39;&#39;</span>.join(g)</div>
<div class="line">&gt;&gt;&gt; list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))</div>
<div class="line">[(<span class="stringliteral">&#39;A&#39;</span>, <span class="stringliteral">&#39;aaa&#39;</span>), (<span class="stringliteral">&#39;B&#39;</span>, <span class="stringliteral">&#39;bbb&#39;</span>), (<span class="stringliteral">&#39;C&#39;</span>, <span class="stringliteral">&#39;ccc&#39;</span>)]</div>
</div><!-- fragment --><p> Each optional argument defaults to an identity function if not specified.</p>
<p>:func:<code>groupby_transform</code> is useful when grouping elements of an iterable using a separate iterable as the key. To do this, :func:<code>zip</code> the iterables and pass a <em>keyfunc</em> that extracts the first element and a <em>valuefunc</em> that extracts the second element::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</div>
<div class="line">&gt;&gt;&gt; keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]</div>
<div class="line">&gt;&gt;&gt; values = <span class="stringliteral">&#39;abcdefghi&#39;</span></div>
<div class="line">&gt;&gt;&gt; iterable = zip(keys, values)</div>
<div class="line">&gt;&gt;&gt; grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))</div>
<div class="line">&gt;&gt;&gt; [(k, <span class="stringliteral">&#39;&#39;</span>.join(g)) <span class="keywordflow">for</span> k, g <span class="keywordflow">in</span> grouper]</div>
<div class="line">[(0, <span class="stringliteral">&#39;ab&#39;</span>), (1, <span class="stringliteral">&#39;cde&#39;</span>), (2, <span class="stringliteral">&#39;fgh&#39;</span>), (3, <span class="stringliteral">&#39;i&#39;</span>)]</div>
</div><!-- fragment --><p> Note that the order of items in the iterable is significant. Only adjacent items are grouped together, so if you don't want any duplicate groups, you should sort the iterable by the key function. </p>

</div>
</div>
<a id="a9c641087a4891d3ac5b40616a3394bd5" name="a9c641087a4891d3ac5b40616a3394bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c641087a4891d3ac5b40616a3394bd5">&#9670;&#160;</a></span>ichunked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.ichunked </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Break <em>iterable</em> into sub-iterables with <em>n</em> elements each. </p>
<p>:func:<code>ichunked</code> is like :func:<code>chunked</code>, but it yields iterables instead of lists.</p>
<p>If the sub-iterables are read in order, the elements of <em>iterable</em> won't be stored in memory. If they are read out of order, :func:<code>itertools.tee</code> is used to cache elements as necessary.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">from</span> itertools <span class="keyword">import</span> count</div>
<div class="line">&gt;&gt;&gt; all_chunks = ichunked(count(), 4)</div>
<div class="line">&gt;&gt;&gt; c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)</div>
<div class="line">&gt;&gt;&gt; list(c_2)  <span class="comment"># c_1&#39;s elements have been cached; c_3&#39;s haven&#39;t been</span></div>
<div class="line">[4, 5, 6, 7]</div>
<div class="line">&gt;&gt;&gt; list(c_1)</div>
<div class="line">[0, 1, 2, 3]</div>
<div class="line">&gt;&gt;&gt; list(c_3)</div>
<div class="line">[8, 9, 10, 11]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a64c69fff987516a452aa90c06d24885e" name="a64c69fff987516a452aa90c06d24885e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c69fff987516a452aa90c06d24885e">&#9670;&#160;</a></span>ilen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.ilen </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of items in <em>iterable</em>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; ilen(x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> range(1000000) <span class="keywordflow">if</span> x % 3 == 0)</div>
<div class="line">333334</div>
</div><!-- fragment --><p> This consumes the iterable, so handle with care. </p>

</div>
</div>
<a id="a6a550537ce14e8b31de79d09cbf72ab2" name="a6a550537ce14e8b31de79d09cbf72ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a550537ce14e8b31de79d09cbf72ab2">&#9670;&#160;</a></span>interleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.interleave </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>iterables</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new iterable yielding from each iterable in turn, until the shortest is exhausted. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(interleave([1, 2, 3], [4, 5], [6, 7, 8]))</div>
<div class="line">[1, 4, 6, 2, 5, 7]</div>
</div><!-- fragment --><p> For a version that doesn't terminate after the shortest iterable is exhausted, see :func:<code>interleave_longest</code>. </p>

</div>
</div>
<a id="aa1803700181e28e4201ab209a3da924d" name="aa1803700181e28e4201ab209a3da924d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1803700181e28e4201ab209a3da924d">&#9670;&#160;</a></span>interleave_longest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.interleave_longest </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>iterables</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new iterable yielding from each iterable in turn, skipping any that are exhausted. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))</div>
<div class="line">[1, 4, 6, 2, 5, 7, 3, 8]</div>
</div><!-- fragment --><p> This function produces the same output as :func:<code>roundrobin</code>, but may perform better for some inputs (in particular when the number of iterables is large). </p>

</div>
</div>
<a id="a511fc6f0275c765800910360d1f96dc0" name="a511fc6f0275c765800910360d1f96dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511fc6f0275c765800910360d1f96dc0">&#9670;&#160;</a></span>intersperse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.intersperse </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>e</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersperse filler element <em>e</em> among the items in <em>iterable</em>, leaving <em>n</em> items between each filler element. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(intersperse(<span class="stringliteral">&#39;!&#39;</span>, [1, 2, 3, 4, 5]))</div>
<div class="line">[1, <span class="stringliteral">&#39;!&#39;</span>, 2, <span class="stringliteral">&#39;!&#39;</span>, 3, <span class="stringliteral">&#39;!&#39;</span>, 4, <span class="stringliteral">&#39;!&#39;</span>, 5]</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; list(intersperse(<span class="keywordtype">None</span>, [1, 2, 3, 4, 5], n=2))</div>
<div class="line">[1, 2, <span class="keywordtype">None</span>, 3, 4, <span class="keywordtype">None</span>, 5]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a81cbbbf641f0a69938658857aacd4a4b" name="a81cbbbf641f0a69938658857aacd4a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cbbbf641f0a69938658857aacd4a4b">&#9670;&#160;</a></span>is_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.is_sorted </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>key</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>reverse</em><span class="paramdefsep"> = </span><span class="paramdefval">False</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>True</code> if the items of iterable are in sorted order, and <code>False</code> otherwise. </p>
<p><em>key</em> and <em>reverse</em> have the same meaning that they do in the built-in :func:<code>sorted</code> function.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; is_sorted([<span class="stringliteral">&#39;1&#39;</span>, <span class="stringliteral">&#39;2&#39;</span>, <span class="stringliteral">&#39;3&#39;</span>, <span class="stringliteral">&#39;4&#39;</span>, <span class="stringliteral">&#39;5&#39;</span>], key=int)</div>
<div class="line"><span class="keyword">True</span></div>
<div class="line">&gt;&gt;&gt; is_sorted([5, 4, 3, 1, 2], reverse=<span class="keyword">True</span>)</div>
<div class="line"><span class="keyword">False</span></div>
</div><!-- fragment --><p> The function returns <code>False</code> after encountering the first out-of-order item. If there are no out-of-order items, the iterable is exhausted. </p>

</div>
</div>
<a id="a17348f255369895951eeb91ce27eab84" name="a17348f255369895951eeb91ce27eab84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17348f255369895951eeb91ce27eab84">&#9670;&#160;</a></span>iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.iterate </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>start</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>start</code>, <code>func(start)</code>, <code>func(func(start))</code>, ... </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">from</span> itertools <span class="keyword">import</span> islice</div>
<div class="line">&gt;&gt;&gt; list(islice(iterate(<span class="keyword">lambda</span> x: 2*x, 1), 10))</div>
<div class="line">[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8451a225701bd3bc60ca00f234062208" name="a8451a225701bd3bc60ca00f234062208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8451a225701bd3bc60ca00f234062208">&#9670;&#160;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.last </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>default</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ac9e7235e60a759a922fdec5a1c512922">_marker</a></span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the last item of <em>iterable</em>, or <em>default</em> if <em>iterable</em> is empty. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; last([0, 1, 2, 3])</div>
<div class="line">3</div>
<div class="line">&gt;&gt;&gt; last([], <span class="stringliteral">&#39;some default&#39;</span>)</div>
<div class="line"><span class="stringliteral">&#39;some default&#39;</span></div>
</div><!-- fragment --><p> If <em>default</em> is not provided and there are no items in the iterable, raise <code>ValueError</code>. </p>

</div>
</div>
<a id="a05e18ee5ccec970465321f705ee1e11b" name="a05e18ee5ccec970465321f705ee1e11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e18ee5ccec970465321f705ee1e11b">&#9670;&#160;</a></span>locate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.locate </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pred</em><span class="paramdefsep"> = </span><span class="paramdefval">bool</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window_size</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the index of each item in <em>iterable</em> for which <em>pred</em> returns <code>True</code>. </p>
<p><em>pred</em> defaults to :func:<code>bool</code>, which will select truthy items:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(locate([0, 1, 1, 0, 1, 0, 0]))</div>
<div class="line">[1, 2, 4]</div>
</div><!-- fragment --><p> Set <em>pred</em> to a custom function to, e.g., find the indexes for a particular item.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(locate([<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>], <span class="keyword">lambda</span> x: x == <span class="stringliteral">&#39;b&#39;</span>))</div>
<div class="line">[1, 3]</div>
</div><!-- fragment --><p> If <em>window_size</em> is given, then the <em>pred</em> function will be called with that many items. This enables searching for sub-sequences:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]</div>
<div class="line">&gt;&gt;&gt; pred = <span class="keyword">lambda</span> *args: args == (1, 2, 3)</div>
<div class="line">&gt;&gt;&gt; list(locate(iterable, pred=pred, window_size=3))</div>
<div class="line">[1, 5, 9]</div>
</div><!-- fragment --><p> Use with :func:<code>seekable</code> to find indexes and then retrieve the associated items:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">from</span> itertools <span class="keyword">import</span> count</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">from</span> more_itertools <span class="keyword">import</span> seekable</div>
<div class="line">&gt;&gt;&gt; source = (3 * n + 1 <span class="keywordflow">if</span> (n % 2) <span class="keywordflow">else</span> n // 2 <span class="keywordflow">for</span> n <span class="keywordflow">in</span> count())</div>
<div class="line">&gt;&gt;&gt; it = seekable(source)</div>
<div class="line">&gt;&gt;&gt; pred = <span class="keyword">lambda</span> x: x &gt; 100</div>
<div class="line">&gt;&gt;&gt; indexes = locate(it, pred=pred)</div>
<div class="line">&gt;&gt;&gt; i = next(indexes)</div>
<div class="line">&gt;&gt;&gt; it.seek(i)</div>
<div class="line">&gt;&gt;&gt; next(it)</div>
<div class="line">106</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2b0712cc8a0f49172287bf947e453677" name="a2b0712cc8a0f49172287bf947e453677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0712cc8a0f49172287bf947e453677">&#9670;&#160;</a></span>lstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.lstrip </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the items from <em>iterable</em>, but strip any from the beginning for which <em>pred</em> returns <code>True</code>. </p>
<p>For example, to remove a set of items from the start of an iterable:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = (<span class="keywordtype">None</span>, <span class="keyword">False</span>, <span class="keywordtype">None</span>, 1, 2, <span class="keywordtype">None</span>, 3, <span class="keyword">False</span>, <span class="keywordtype">None</span>)</div>
<div class="line">&gt;&gt;&gt; pred = <span class="keyword">lambda</span> x: x <span class="keywordflow">in</span> {<span class="keywordtype">None</span>, <span class="keyword">False</span>, <span class="stringliteral">&#39;&#39;</span>}</div>
<div class="line">&gt;&gt;&gt; list(lstrip(iterable, pred))</div>
<div class="line">[1, 2, <span class="keywordtype">None</span>, 3, <span class="keyword">False</span>, <span class="keywordtype">None</span>]</div>
</div><!-- fragment --><p> This function is analogous to to :func:<code>str.lstrip</code>, and is essentially an wrapper for :func:<code>itertools.dropwhile</code>. </p>

</div>
</div>
<a id="a21e8616c9a2d21c6b3b81e351225bf60" name="a21e8616c9a2d21c6b3b81e351225bf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e8616c9a2d21c6b3b81e351225bf60">&#9670;&#160;</a></span>make_decorator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.make_decorator </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>wrapping_func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>result_index</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a decorator version of <em>wrapping_func</em>, which is a function that modifies an iterable. </p>
<p><em>result_index</em> is the position in that function's signature where the iterable goes.</p>
<p>This lets you use itertools on the "production end," i.e. at function definition. This can augment what the function returns without changing the function's code.</p>
<p>For example, to produce a decorator version of :func:<code>chunked</code>:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">from</span> more_itertools <span class="keyword">import</span> chunked</div>
<div class="line">&gt;&gt;&gt; chunker = make_decorator(chunked, result_index=0)</div>
<div class="line">&gt;&gt;&gt; <span class="preprocessor">@chunker(3)</span></div>
<div class="line">... <span class="keyword">def </span>iter_range(n):</div>
<div class="line">...     <span class="keywordflow">return</span> iter(range(n))</div>
<div class="line">...</div>
<div class="line">&gt;&gt;&gt; list(iter_range(9))</div>
<div class="line">[[0, 1, 2], [3, 4, 5], [6, 7, 8]]</div>
</div><!-- fragment --><p> To only allow truthy items to be returned:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; truth_serum = make_decorator(filter, result_index=1)</div>
<div class="line">&gt;&gt;&gt; <span class="preprocessor">@truth_serum(bool)</span></div>
<div class="line">... <span class="keyword">def </span>boolean_test():</div>
<div class="line">...     <span class="keywordflow">return</span> [0, 1, <span class="stringliteral">&#39;&#39;</span>, <span class="stringliteral">&#39; &#39;</span>, <span class="keyword">False</span>, <span class="keyword">True</span>]</div>
<div class="line">...</div>
<div class="line">&gt;&gt;&gt; list(boolean_test())</div>
<div class="line">[1, <span class="stringliteral">&#39; &#39;</span>, <span class="keyword">True</span>]</div>
</div><!-- fragment --><p> The :func:<code>peekable</code> and :func:<code>seekable</code> wrappers make for practical decorators:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">from</span> more_itertools <span class="keyword">import</span> peekable</div>
<div class="line">&gt;&gt;&gt; peekable_function = make_decorator(peekable)</div>
<div class="line">&gt;&gt;&gt; <span class="preprocessor">@peekable_function()</span></div>
<div class="line">... <span class="keyword">def </span>str_range(*args):</div>
<div class="line">...     <span class="keywordflow">return</span> (str(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> range(*args))</div>
<div class="line">...</div>
<div class="line">&gt;&gt;&gt; it = str_range(1, 20, 2)</div>
<div class="line">&gt;&gt;&gt; next(it), next(it), next(it)</div>
<div class="line">(<span class="stringliteral">&#39;1&#39;</span>, <span class="stringliteral">&#39;3&#39;</span>, <span class="stringliteral">&#39;5&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; it.peek()</div>
<div class="line"><span class="stringliteral">&#39;7&#39;</span></div>
<div class="line">&gt;&gt;&gt; next(it)</div>
<div class="line"><span class="stringliteral">&#39;7&#39;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af5f31c6152daaffa29cd357b6080416f" name="af5f31c6152daaffa29cd357b6080416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f31c6152daaffa29cd357b6080416f">&#9670;&#160;</a></span>map_except()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.map_except </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>function</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>exceptions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform each item from <em>iterable</em> with <em>function</em> and yield the result, unless <em>function</em> raises one of the specified <em>exceptions</em>. </p>
<p><em>function</em> is called to transform each item in <em>iterable</em>. It should be a accept one argument.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [<span class="stringliteral">&#39;1&#39;</span>, <span class="stringliteral">&#39;2&#39;</span>, <span class="stringliteral">&#39;three&#39;</span>, <span class="stringliteral">&#39;4&#39;</span>, <span class="keywordtype">None</span>]</div>
<div class="line">&gt;&gt;&gt; list(map_except(int, iterable, ValueError, TypeError))</div>
<div class="line">[1, 2, 4]</div>
</div><!-- fragment --><p> If an exception other than one given by <em>exceptions</em> is raised by <em>function</em>, it is raised like normal. </p>

</div>
</div>
<a id="a45c533b865a3514e16c54991daba7af2" name="a45c533b865a3514e16c54991daba7af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c533b865a3514e16c54991daba7af2">&#9670;&#160;</a></span>map_reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.map_reduce </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>keyfunc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>valuefunc</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>reducefunc</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a dictionary that maps the items in <em>iterable</em> to categories defined by <em>keyfunc</em>, transforms them with <em>valuefunc</em>, and then summarizes them by category with <em>reducefunc</em>. </p>
<p><em>valuefunc</em> defaults to the identity function if it is unspecified. If <em>reducefunc</em> is unspecified, no summarization takes place:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; keyfunc = <span class="keyword">lambda</span> x: x.upper()</div>
<div class="line">&gt;&gt;&gt; result = map_reduce(<span class="stringliteral">&#39;abbccc&#39;</span>, keyfunc)</div>
<div class="line">&gt;&gt;&gt; sorted(result.items())</div>
<div class="line">[(<span class="stringliteral">&#39;A&#39;</span>, [<span class="stringliteral">&#39;a&#39;</span>]), (<span class="stringliteral">&#39;B&#39;</span>, [<span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>]), (<span class="stringliteral">&#39;C&#39;</span>, [<span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>])]</div>
</div><!-- fragment --><p> Specifying <em>valuefunc</em> transforms the categorized items:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; keyfunc = <span class="keyword">lambda</span> x: x.upper()</div>
<div class="line">&gt;&gt;&gt; valuefunc = <span class="keyword">lambda</span> x: 1</div>
<div class="line">&gt;&gt;&gt; result = map_reduce(<span class="stringliteral">&#39;abbccc&#39;</span>, keyfunc, valuefunc)</div>
<div class="line">&gt;&gt;&gt; sorted(result.items())</div>
<div class="line">[(<span class="stringliteral">&#39;A&#39;</span>, [1]), (<span class="stringliteral">&#39;B&#39;</span>, [1, 1]), (<span class="stringliteral">&#39;C&#39;</span>, [1, 1, 1])]</div>
</div><!-- fragment --><p> Specifying <em>reducefunc</em> summarizes the categorized items:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; keyfunc = <span class="keyword">lambda</span> x: x.upper()</div>
<div class="line">&gt;&gt;&gt; valuefunc = <span class="keyword">lambda</span> x: 1</div>
<div class="line">&gt;&gt;&gt; reducefunc = sum</div>
<div class="line">&gt;&gt;&gt; result = map_reduce(<span class="stringliteral">&#39;abbccc&#39;</span>, keyfunc, valuefunc, reducefunc)</div>
<div class="line">&gt;&gt;&gt; sorted(result.items())</div>
<div class="line">[(<span class="stringliteral">&#39;A&#39;</span>, 1), (<span class="stringliteral">&#39;B&#39;</span>, 2), (<span class="stringliteral">&#39;C&#39;</span>, 3)]</div>
</div><!-- fragment --><p> You may want to filter the input iterable before applying the map/reduce procedure:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; all_items = range(30)</div>
<div class="line">&gt;&gt;&gt; items = [x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> all_items <span class="keywordflow">if</span> 10 &lt;= x &lt;= 20]  <span class="comment"># Filter</span></div>
<div class="line">&gt;&gt;&gt; keyfunc = <span class="keyword">lambda</span> x: x % 2  <span class="comment"># Evens map to 0; odds to 1</span></div>
<div class="line">&gt;&gt;&gt; categories = map_reduce(items, keyfunc=keyfunc)</div>
<div class="line">&gt;&gt;&gt; sorted(categories.items())</div>
<div class="line">[(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]</div>
<div class="line">&gt;&gt;&gt; summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)</div>
<div class="line">&gt;&gt;&gt; sorted(summaries.items())</div>
<div class="line">[(0, 90), (1, 75)]</div>
</div><!-- fragment --><p> Note that all items in the iterable are gathered into a list before the summarization step, which may require significant storage.</p>
<p>The returned object is a :obj:<code>collections.defaultdict</code> with the <code>default_factory</code> set to <code>None</code>, such that it behaves like a normal dictionary. </p>

</div>
</div>
<a id="a887baec1ac1113ad302338e44bef29e7" name="a887baec1ac1113ad302338e44bef29e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887baec1ac1113ad302338e44bef29e7">&#9670;&#160;</a></span>mark_ends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.mark_ends </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield 3-tuples of the form <code>(is_first, is_last, item)</code>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(mark_ends(<span class="stringliteral">&#39;ABC&#39;</span>))</div>
<div class="line">[(<span class="keyword">True</span>, <span class="keyword">False</span>, <span class="stringliteral">&#39;A&#39;</span>), (<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="stringliteral">&#39;B&#39;</span>), (<span class="keyword">False</span>, <span class="keyword">True</span>, <span class="stringliteral">&#39;C&#39;</span>)]</div>
</div><!-- fragment --><p> Use this when looping over an iterable to take special action on its first and/or last items:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [<span class="stringliteral">&#39;Header&#39;</span>, 100, 200, <span class="stringliteral">&#39;Footer&#39;</span>]</div>
<div class="line">&gt;&gt;&gt; total = 0</div>
<div class="line">&gt;&gt;&gt; <span class="keywordflow">for</span> is_first, is_last, item <span class="keywordflow">in</span> mark_ends(iterable):</div>
<div class="line">...     <span class="keywordflow">if</span> is_first:</div>
<div class="line">...         <span class="keywordflow">continue</span>  <span class="comment"># Skip the header</span></div>
<div class="line">...     <span class="keywordflow">if</span> is_last:</div>
<div class="line">...         <span class="keywordflow">continue</span>  <span class="comment"># Skip the footer</span></div>
<div class="line">...     total += item</div>
<div class="line">&gt;&gt;&gt; print(total)</div>
<div class="line">300</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7b1c123134b401ca372bc206b6fae7ba" name="a7b1c123134b401ca372bc206b6fae7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1c123134b401ca372bc206b6fae7ba">&#9670;&#160;</a></span>nth_or_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.nth_or_last </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>default</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ac9e7235e60a759a922fdec5a1c512922">_marker</a></span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the nth or the last item of <em>iterable</em>, or <em>default</em> if <em>iterable</em> is empty. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; nth_or_last([0, 1, 2, 3], 2)</div>
<div class="line">2</div>
<div class="line">&gt;&gt;&gt; nth_or_last([0, 1], 2)</div>
<div class="line">1</div>
<div class="line">&gt;&gt;&gt; nth_or_last([], 0, <span class="stringliteral">&#39;some default&#39;</span>)</div>
<div class="line"><span class="stringliteral">&#39;some default&#39;</span></div>
</div><!-- fragment --><p> If <em>default</em> is not provided and there are no items in the iterable, raise <code>ValueError</code>. </p>

</div>
</div>
<a id="a1e8fb234f6fe28459220bb2acf7e7024" name="a1e8fb234f6fe28459220bb2acf7e7024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8fb234f6fe28459220bb2acf7e7024">&#9670;&#160;</a></span>nth_permutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.nth_permutation </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>r</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>list(permutations(iterable, r))[index]</code>`. </p>
<p>The subsequences of <em>iterable</em> that are of length <em>r</em> where order is important can be ordered lexicographically. :func:<code>nth_permutation</code> computes the subsequence at sort position <em>index</em> directly, without computing the previous subsequences.</p>
<div class="fragment"><div class="line">    &gt;&gt;&gt; nth_permutation(<span class="stringliteral">&#39;ghijk&#39;</span>, 2, 5)</div>
<div class="line">    (<span class="stringliteral">&#39;h&#39;</span>, <span class="stringliteral">&#39;i&#39;</span>)</div>
<div class="line"> </div>
<div class="line">``ValueError`` will be raised If *r* <span class="keywordflow">is</span> negative <span class="keywordflow">or</span> greater than the length</div>
</div><!-- fragment --><p> of <em>iterable</em>. <code>IndexError</code> will be raised if the given <em>index</em> is invalid. </p>

</div>
</div>
<a id="a0b3159489420e4a47a301c6d2d9c0529" name="a0b3159489420e4a47a301c6d2d9c0529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3159489420e4a47a301c6d2d9c0529">&#9670;&#160;</a></span>nth_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.nth_product </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>list(product(*args))[index]</code>. </p>
<p>The products of <em>args</em> can be ordered lexicographically. :func:<code>nth_product</code> computes the product at sort position <em>index</em> without computing the previous products.</p>
<div class="fragment"><div class="line">    &gt;&gt;&gt; nth_product(8, range(2), range(2), range(2), range(2))</div>
<div class="line">    (1, 0, 0, 0)</div>
<div class="line"> </div>
<div class="line">``IndexError`` will be raised <span class="keywordflow">if</span> the given *index* <span class="keywordflow">is</span> invalid.</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8c28ebee9cc10435df318256129637c0" name="a8c28ebee9cc10435df318256129637c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c28ebee9cc10435df318256129637c0">&#9670;&#160;</a></span>one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.one </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>too_short</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>too_long</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first item from <em>iterable</em>, which is expected to contain only that item. </p>
<p>Raise an exception if <em>iterable</em> is empty or has more than one item.</p>
<p>:func:<code>one</code> is useful for ensuring that an iterable contains only one item. For example, it can be used to retrieve the result of a database query that is expected to return a single row.</p>
<p>If <em>iterable</em> is empty, <code>ValueError</code> will be raised. You may specify a different exception with the <em>too_short</em> keyword:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; it = []</div>
<div class="line">&gt;&gt;&gt; one(it)  <span class="comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line">Traceback (most recent call last):</div>
<div class="line">...</div>
<div class="line">ValueError: too many items <span class="keywordflow">in</span> iterable (expected 1)<span class="stringliteral">&#39;</span></div>
<div class="line"><span class="stringliteral">&gt;&gt;&gt; too_short = IndexError(&#39;too few items&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; one(it, too_short=too_short)  <span class="comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line">Traceback (most recent call last):</div>
<div class="line">...</div>
<div class="line">IndexError: too few items</div>
</div><!-- fragment --><p> Similarly, if <em>iterable</em> contains more than one item, <code>ValueError</code> will be raised. You may specify a different exception with the <em>too_long</em> keyword:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; it = [<span class="stringliteral">&#39;too&#39;</span>, <span class="stringliteral">&#39;many&#39;</span>]</div>
<div class="line">&gt;&gt;&gt; one(it)  <span class="comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line">Traceback (most recent call last):</div>
<div class="line">...</div>
<div class="line">ValueError: Expected exactly one item <span class="keywordflow">in</span> iterable, but got <span class="stringliteral">&#39;too&#39;</span>,</div>
</div><!-- fragment --><p> 'many', and perhaps more. </p><div class="fragment"><div class="line">&gt;&gt;&gt; too_long = RuntimeError</div>
<div class="line">&gt;&gt;&gt; one(it, too_long=too_long)  <span class="comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line">Traceback (most recent call last):</div>
<div class="line">...</div>
<div class="line">RuntimeError</div>
</div><!-- fragment --><p> Note that :func:<code>one</code> attempts to advance <em>iterable</em> twice to ensure there is only one item. See :func:<code>spy</code> or :func:<code>peekable</code> to check iterable contents less destructively. </p>

</div>
</div>
<a id="a6f27ecbe9378a7e871e33d55a980ebc7" name="a6f27ecbe9378a7e871e33d55a980ebc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f27ecbe9378a7e871e33d55a980ebc7">&#9670;&#160;</a></span>only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.only </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>default</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>too_long</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <em>iterable</em> has only one item, return it. </p>
<p>If it has zero items, return <em>default</em>. If it has more than one item, raise the exception given by <em>too_long</em>, which is <code>ValueError</code> by default.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; only([], default=<span class="stringliteral">&#39;missing&#39;</span>)</div>
<div class="line"><span class="stringliteral">&#39;missing&#39;</span></div>
<div class="line">&gt;&gt;&gt; only([1])</div>
<div class="line">1</div>
<div class="line">&gt;&gt;&gt; only([1, 2])  <span class="comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line">Traceback (most recent call last):</div>
<div class="line">...</div>
<div class="line">ValueError: Expected exactly one item <span class="keywordflow">in</span> iterable, but got 1, 2,</div>
</div><!-- fragment --><p> and perhaps more.' </p><div class="fragment"><div class="line">&gt;&gt;&gt; only([1, 2], too_long=TypeError)  <span class="comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line">Traceback (most recent call last):</div>
<div class="line">...</div>
<div class="line">TypeError</div>
</div><!-- fragment --><p> Note that :func:<code>only</code> attempts to advance <em>iterable</em> twice to ensure there is only one item. See :func:<code>spy</code> or :func:<code>peekable</code> to check iterable contents less destructively. </p>

</div>
</div>
<a id="a50adbaec19127d43efcec83b3b67d2e1" name="a50adbaec19127d43efcec83b3b67d2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50adbaec19127d43efcec83b3b67d2e1">&#9670;&#160;</a></span>padded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.padded </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fillvalue</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>next_multiple</em><span class="paramdefsep"> = </span><span class="paramdefval">False</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the elements from <em>iterable</em>, followed by <em>fillvalue</em>, such that at least <em>n</em> items are emitted. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(padded([1, 2, 3], <span class="stringliteral">&#39;?&#39;</span>, 5))</div>
<div class="line">[1, 2, 3, <span class="stringliteral">&#39;?&#39;</span>, <span class="stringliteral">&#39;?&#39;</span>]</div>
</div><!-- fragment --><p> If <em>next_multiple</em> is <code>True</code>, <em>fillvalue</em> will be emitted until the number of items emitted is a multiple of <em>n</em>::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(padded([1, 2, 3, 4], n=3, next_multiple=<span class="keyword">True</span>))</div>
<div class="line">[1, 2, 3, 4, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>]</div>
</div><!-- fragment --><p> If <em>n</em> is <code>None</code>, <em>fillvalue</em> will be emitted indefinitely. </p>

</div>
</div>
<a id="a50ac8728632c6d80de2b0e3f627b1b77" name="a50ac8728632c6d80de2b0e3f627b1b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ac8728632c6d80de2b0e3f627b1b77">&#9670;&#160;</a></span>partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.partitions </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield all possible order-preserving partitions of <em>iterable</em>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = <span class="stringliteral">&#39;abc&#39;</span></div>
<div class="line">&gt;&gt;&gt; <span class="keywordflow">for</span> part <span class="keywordflow">in</span> partitions(iterable):</div>
<div class="line">...     print([<span class="stringliteral">&#39;&#39;</span>.join(p) <span class="keywordflow">for</span> p <span class="keywordflow">in</span> part])</div>
<div class="line">[<span class="stringliteral">&#39;abc&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;bc&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;ab&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>]</div>
</div><!-- fragment --><p> This is unrelated to :func:<code>partition</code>. </p>

</div>
</div>
<a id="aa8a435858b2e240b461187e43423a959" name="aa8a435858b2e240b461187e43423a959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a435858b2e240b461187e43423a959">&#9670;&#160;</a></span>permutation_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.permutation_index </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>element</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>list(permutations(iterable, r)).index(element)</code>`. </p>
<p>The subsequences of <em>iterable</em> that are of length <em>r</em> where order is important can be ordered lexicographically. :func:<code>permutation_index</code> computes the index of the first <em>element</em> directly, without computing the previous permutations.</p>
<div class="fragment"><div class="line">    &gt;&gt;&gt; permutation_index([1, 3, 2], range(5))</div>
<div class="line">    19</div>
<div class="line"> </div>
<div class="line">``ValueError`` will be raised <span class="keywordflow">if</span> the given *element* isn<span class="stringliteral">&#39;t one of the</span></div>
</div><!-- fragment --><p> permutations of <em>iterable</em>. </p>

</div>
</div>
<a id="ad04f1738abb04e3d9334e3daf689c4a5" name="ad04f1738abb04e3d9334e3daf689c4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04f1738abb04e3d9334e3daf689c4a5">&#9670;&#160;</a></span>product_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.product_index </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>element</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>list(product(*args)).index(element)</code> </p>
<p>The products of <em>args</em> can be ordered lexicographically. :func:<code>product_index</code> computes the first index of <em>element</em> without computing the previous products.</p>
<div class="fragment"><div class="line">    &gt;&gt;&gt; product_index([8, 2], range(10), range(5))</div>
<div class="line">    42</div>
<div class="line"> </div>
<div class="line">``ValueError`` will be raised <span class="keywordflow">if</span> the given *element* isn<span class="stringliteral">&#39;t in the product</span></div>
</div><!-- fragment --><p> of <em>args</em>. </p>

</div>
</div>
<a id="aa5425f753dfd8559de42b9fc12c28fc2" name="aa5425f753dfd8559de42b9fc12c28fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5425f753dfd8559de42b9fc12c28fc2">&#9670;&#160;</a></span>repeat_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.repeat_last </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>default</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After the <em>iterable</em> is exhausted, keep yielding its last element. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(islice(repeat_last(range(3)), 5))</div>
<div class="line">[0, 1, 2, 2, 2]</div>
</div><!-- fragment --><p> If the iterable is empty, yield <em>default</em> forever::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(islice(repeat_last(range(0), 42), 5))</div>
<div class="line">[42, 42, 42, 42, 42]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab8daa550cec9c16c67c4500228d1e08d" name="ab8daa550cec9c16c67c4500228d1e08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8daa550cec9c16c67c4500228d1e08d">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.replace </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pred</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>substitutes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>count</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window_size</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the items from <em>iterable</em>, replacing the items for which <em>pred</em> returns <code>True</code> with the items from the iterable <em>substitutes</em>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1]</div>
<div class="line">&gt;&gt;&gt; pred = <span class="keyword">lambda</span> x: x == 0</div>
<div class="line">&gt;&gt;&gt; substitutes = (2, 3)</div>
<div class="line">&gt;&gt;&gt; list(replace(iterable, pred, substitutes))</div>
<div class="line">[1, 1, 2, 3, 1, 1, 2, 3, 1, 1]</div>
</div><!-- fragment --><p> If <em>count</em> is given, the number of replacements will be limited:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]</div>
<div class="line">&gt;&gt;&gt; pred = <span class="keyword">lambda</span> x: x == 0</div>
<div class="line">&gt;&gt;&gt; substitutes = [<span class="keywordtype">None</span>]</div>
<div class="line">&gt;&gt;&gt; list(replace(iterable, pred, substitutes, count=2))</div>
<div class="line">[1, 1, <span class="keywordtype">None</span>, 1, 1, <span class="keywordtype">None</span>, 1, 1, 0]</div>
</div><!-- fragment --><p> Use <em>window_size</em> to control the number of items passed as arguments to <em>pred</em>. This allows for locating and replacing subsequences.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [0, 1, 2, 5, 0, 1, 2, 5]</div>
<div class="line">&gt;&gt;&gt; window_size = 3</div>
<div class="line">&gt;&gt;&gt; pred = <span class="keyword">lambda</span> *args: args == (0, 1, 2)  <span class="comment"># 3 items passed to pred</span></div>
<div class="line">&gt;&gt;&gt; substitutes = [3, 4] <span class="comment"># Splice in these items</span></div>
<div class="line">&gt;&gt;&gt; list(replace(iterable, pred, substitutes, window_size=window_size))</div>
<div class="line">[3, 4, 5, 3, 4, 5]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a31f682ab11fa2bc3a54def3f13ae20d9" name="a31f682ab11fa2bc3a54def3f13ae20d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f682ab11fa2bc3a54def3f13ae20d9">&#9670;&#160;</a></span>rlocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.rlocate </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pred</em><span class="paramdefsep"> = </span><span class="paramdefval">bool</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window_size</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the index of each item in <em>iterable</em> for which <em>pred</em> returns <code>True</code>, starting from the right and moving left. </p>
<p><em>pred</em> defaults to :func:<code>bool</code>, which will select truthy items:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(rlocate([0, 1, 1, 0, 1, 0, 0]))  <span class="comment"># Truthy at 1, 2, and 4</span></div>
<div class="line">[4, 2, 1]</div>
</div><!-- fragment --><p> Set <em>pred</em> to a custom function to, e.g., find the indexes for a particular item:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = iter(<span class="stringliteral">&#39;abcb&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; pred = <span class="keyword">lambda</span> x: x == <span class="stringliteral">&#39;b&#39;</span></div>
<div class="line">&gt;&gt;&gt; list(rlocate(iterable, pred))</div>
<div class="line">[3, 1]</div>
</div><!-- fragment --><p> If <em>window_size</em> is given, then the <em>pred</em> function will be called with that many items. This enables searching for sub-sequences:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]</div>
<div class="line">&gt;&gt;&gt; pred = <span class="keyword">lambda</span> *args: args == (1, 2, 3)</div>
<div class="line">&gt;&gt;&gt; list(rlocate(iterable, pred=pred, window_size=3))</div>
<div class="line">[9, 5, 1]</div>
</div><!-- fragment --><p> Beware, this function won't return anything for infinite iterables. If <em>iterable</em> is reversible, <code>rlocate</code> will reverse it and search from the right. Otherwise, it will search from the left and return the results in reverse order.</p>
<p>See :func:<code>locate</code> to for other example applications. </p>

</div>
</div>
<a id="abafac6a26effb97d5579c5412d30bc77" name="abafac6a26effb97d5579c5412d30bc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafac6a26effb97d5579c5412d30bc77">&#9670;&#160;</a></span>rstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.rstrip </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the items from <em>iterable</em>, but strip any from the end for which <em>pred</em> returns <code>True</code>. </p>
<p>For example, to remove a set of items from the end of an iterable:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = (<span class="keywordtype">None</span>, <span class="keyword">False</span>, <span class="keywordtype">None</span>, 1, 2, <span class="keywordtype">None</span>, 3, <span class="keyword">False</span>, <span class="keywordtype">None</span>)</div>
<div class="line">&gt;&gt;&gt; pred = <span class="keyword">lambda</span> x: x <span class="keywordflow">in</span> {<span class="keywordtype">None</span>, <span class="keyword">False</span>, <span class="stringliteral">&#39;&#39;</span>}</div>
<div class="line">&gt;&gt;&gt; list(rstrip(iterable, pred))</div>
<div class="line">[<span class="keywordtype">None</span>, <span class="keyword">False</span>, <span class="keywordtype">None</span>, 1, 2, <span class="keywordtype">None</span>, 3]</div>
</div><!-- fragment --><p> This function is analogous to :func:<code>str.rstrip</code>. </p>

</div>
</div>
<a id="a1405cfbac3f502521faf280895b1920a" name="a1405cfbac3f502521faf280895b1920a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1405cfbac3f502521faf280895b1920a">&#9670;&#160;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.sample </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>weights</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <em>k</em>-length list of elements chosen (without replacement) from the <em>iterable</em>. </p>
<p>Like :func:<code>random.sample</code>, but works on iterables of unknown length.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = range(100)</div>
<div class="line">&gt;&gt;&gt; sample(iterable, 5)  <span class="comment"># doctest: +SKIP</span></div>
<div class="line">[81, 60, 96, 16, 4]</div>
</div><!-- fragment --><p> An iterable with <em>weights</em> may also be given:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = range(100)</div>
<div class="line">&gt;&gt;&gt; weights = (i * i + 1 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(100))</div>
<div class="line">&gt;&gt;&gt; sampled = sample(iterable, 5, weights=weights)  <span class="comment"># doctest: +SKIP</span></div>
<div class="line">[79, 67, 74, 66, 78]</div>
</div><!-- fragment --><p> The algorithm can also be used to generate weighted random permutations. The relative weight of each item determines the probability that it appears late in the permutation.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; data = <span class="stringliteral">&quot;abcdefgh&quot;</span></div>
<div class="line">&gt;&gt;&gt; weights = range(1, len(data) + 1)</div>
<div class="line">&gt;&gt;&gt; sample(data, k=len(data), weights=weights)  <span class="comment"># doctest: +SKIP</span></div>
<div class="line">[<span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;e&#39;</span>, <span class="stringliteral">&#39;g&#39;</span>, <span class="stringliteral">&#39;d&#39;</span>, <span class="stringliteral">&#39;h&#39;</span>, <span class="stringliteral">&#39;f&#39;</span>]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a09aba9fcbb4adacab1fdac7c921e39b0" name="a09aba9fcbb4adacab1fdac7c921e39b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09aba9fcbb4adacab1fdac7c921e39b0">&#9670;&#160;</a></span>set_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.set_partitions </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the set partitions of <em>iterable</em> into <em>k</em> parts. </p>
<p>Set partitions are not order-preserving.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = <span class="stringliteral">&#39;abc&#39;</span></div>
<div class="line">&gt;&gt;&gt; <span class="keywordflow">for</span> part <span class="keywordflow">in</span> set_partitions(iterable, 2):</div>
<div class="line">...     print([<span class="stringliteral">&#39;&#39;</span>.join(p) <span class="keywordflow">for</span> p <span class="keywordflow">in</span> part])</div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;bc&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;ab&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;ac&#39;</span>]</div>
</div><!-- fragment --><p> If <em>k</em> is not given, every set partition is generated.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = <span class="stringliteral">&#39;abc&#39;</span></div>
<div class="line">&gt;&gt;&gt; <span class="keywordflow">for</span> part <span class="keywordflow">in</span> set_partitions(iterable):</div>
<div class="line">...     print([<span class="stringliteral">&#39;&#39;</span>.join(p) <span class="keywordflow">for</span> p <span class="keywordflow">in</span> part])</div>
<div class="line">[<span class="stringliteral">&#39;abc&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;bc&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;ab&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;ac&#39;</span>]</div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa9fd87a60e18304da46bc5b9b42b14b1" name="aa9fd87a60e18304da46bc5b9b42b14b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fd87a60e18304da46bc5b9b42b14b1">&#9670;&#160;</a></span>side_effect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.side_effect </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>chunk_size</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>before</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>after</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke <em>func</em> on each item in <em>iterable</em> (or on each <em>chunk_size</em> group of items) before yielding the item. </p>
<p><code>func</code> must be a function that takes a single argument. Its return value will be discarded.</p>
<p><em>before</em> and <em>after</em> are optional functions that take no arguments. They will be executed before iteration starts and after it ends, respectively.</p>
<p><code>side_effect</code> can be used for logging, updating progress bars, or anything that is not functionally "pure."</p>
<p>Emitting a status message:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">from</span> more_itertools <span class="keyword">import</span> consume</div>
<div class="line">&gt;&gt;&gt; func = <span class="keyword">lambda</span> item: print(<span class="stringliteral">&#39;Received {}&#39;</span>.format(item))</div>
<div class="line">&gt;&gt;&gt; consume(side_effect(func, range(2)))</div>
</div><!-- fragment --><p> Received 0 Received 1</p>
<p>Operating on chunks of items:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; pair_sums = []</div>
<div class="line">&gt;&gt;&gt; func = <span class="keyword">lambda</span> chunk: pair_sums.append(sum(chunk))</div>
<div class="line">&gt;&gt;&gt; list(side_effect(func, [0, 1, 2, 3, 4, 5], 2))</div>
<div class="line">[0, 1, 2, 3, 4, 5]</div>
<div class="line">&gt;&gt;&gt; list(pair_sums)</div>
<div class="line">[1, 5, 9]</div>
</div><!-- fragment --><p> Writing to a file-like object:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">from</span> io <span class="keyword">import</span> StringIO</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">from</span> more_itertools <span class="keyword">import</span> consume</div>
<div class="line">&gt;&gt;&gt; f = StringIO()</div>
<div class="line">&gt;&gt;&gt; func = <span class="keyword">lambda</span> x: print(x, file=f)</div>
<div class="line">&gt;&gt;&gt; before = <span class="keyword">lambda</span>: print(<span class="stringliteral">u&#39;HEADER&#39;</span>, file=f)</div>
<div class="line">&gt;&gt;&gt; after = f.close</div>
<div class="line">&gt;&gt;&gt; it = [<span class="stringliteral">u&#39;a&#39;</span>, <span class="stringliteral">u&#39;b&#39;</span>, <span class="stringliteral">u&#39;c&#39;</span>]</div>
<div class="line">&gt;&gt;&gt; consume(side_effect(func, it, before=before, after=after))</div>
<div class="line">&gt;&gt;&gt; f.closed</div>
<div class="line"><span class="keyword">True</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a56d69cf216f30f8434561bc98a0dd779" name="a56d69cf216f30f8434561bc98a0dd779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d69cf216f30f8434561bc98a0dd779">&#9670;&#160;</a></span>sliced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.sliced </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>seq</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">False</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield slices of length <em>n</em> from the sequence <em>seq</em>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(sliced((1, 2, 3, 4, 5, 6), 3))</div>
<div class="line">[(1, 2, 3), (4, 5, 6)]</div>
</div><!-- fragment --><p> By the default, the last yielded slice will have fewer than <em>n</em> elements if the length of <em>seq</em> is not divisible by <em>n</em>:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))</div>
<div class="line">[(1, 2, 3), (4, 5, 6), (7, 8)]</div>
</div><!-- fragment --><p> If the length of <em>seq</em> is not divisible by <em>n</em> and <em>strict</em> is <code>True</code>, then <code>ValueError</code> will be raised before the last slice is yielded.</p>
<p>This function will only work for iterables that support slicing. For non-sliceable iterables, see :func:<code>chunked</code>. </p>

</div>
</div>
<a id="aea9b12c4b7074c419c909ee5b3b0b8cf" name="aea9b12c4b7074c419c909ee5b3b0b8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9b12c4b7074c419c909ee5b3b0b8cf">&#9670;&#160;</a></span>sort_together()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.sort_together </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterables</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>key_list</em><span class="paramdefsep"> = </span><span class="paramdefval">(0,)</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>key</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>reverse</em><span class="paramdefsep"> = </span><span class="paramdefval">False</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the input iterables sorted together, with <em>key_list</em> as the priority for sorting. </p>
<p>All iterables are trimmed to the length of the shortest one.</p>
<p>This can be used like the sorting function in a spreadsheet. If each iterable represents a column of data, the key list determines which columns are used for sorting.</p>
<p>By default, all iterables are sorted using the <code>0</code>-th iterable::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterables = [(4, 3, 2, 1), (<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;d&#39;</span>)]</div>
<div class="line">&gt;&gt;&gt; sort_together(iterables)</div>
<div class="line">[(1, 2, 3, 4), (<span class="stringliteral">&#39;d&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;a&#39;</span>)]</div>
</div><!-- fragment --><p> Set a different key list to sort according to another iterable. Specifying multiple keys dictates how ties are broken::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterables = [(3, 1, 2), (0, 1, 0), (<span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;a&#39;</span>)]</div>
<div class="line">&gt;&gt;&gt; sort_together(iterables, key_list=(1, 2))</div>
<div class="line">[(2, 3, 1), (0, 0, 1), (<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>)]</div>
</div><!-- fragment --><p> To sort by a function of the elements of the iterable, pass a <em>key</em> function. Its arguments are the elements of the iterables corresponding to the key list::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; names = (<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; lengths = (1, 2, 3)</div>
<div class="line">&gt;&gt;&gt; widths = (5, 2, 1)</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">def </span>area(length, width):</div>
<div class="line">...     <span class="keywordflow">return</span> length * width</div>
<div class="line">&gt;&gt;&gt; sort_together([names, lengths, widths], key_list=(1, 2), key=area)</div>
<div class="line">[(<span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;a&#39;</span>), (3, 2, 1), (1, 2, 5)]</div>
</div><!-- fragment --><p> Set <em>reverse</em> to <code>True</code> to sort in descending order.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; sort_together([(1, 2, 3), (<span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;a&#39;</span>)], reverse=<span class="keyword">True</span>)</div>
<div class="line">[(3, 2, 1), (<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>)]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aec868cc95b2ee87797046cbf8083e47d" name="aec868cc95b2ee87797046cbf8083e47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec868cc95b2ee87797046cbf8083e47d">&#9670;&#160;</a></span>split_after()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.split_after </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pred</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maxsplit</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield lists of items from <em>iterable</em>, where each list ends with an item where callable <em>pred</em> returns <code>True</code>: </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_after(<span class="stringliteral">&#39;one1two2&#39;</span>, <span class="keyword">lambda</span> s: s.isdigit()))</div>
<div class="line">[[<span class="stringliteral">&#39;o&#39;</span>, <span class="stringliteral">&#39;n&#39;</span>, <span class="stringliteral">&#39;e&#39;</span>, <span class="stringliteral">&#39;1&#39;</span>], [<span class="stringliteral">&#39;t&#39;</span>, <span class="stringliteral">&#39;w&#39;</span>, <span class="stringliteral">&#39;o&#39;</span>, <span class="stringliteral">&#39;2&#39;</span>]]</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; list(split_after(range(10), <span class="keyword">lambda</span> n: n % 3 == 0))</div>
<div class="line">[[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]</div>
</div><!-- fragment --><p> At most <em>maxsplit</em> splits are done. If <em>maxsplit</em> is not specified or -1, then there is no limit on the number of splits:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_after(range(10), <span class="keyword">lambda</span> n: n % 3 == 0, maxsplit=2))</div>
<div class="line">[[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0c21ccdd1a1500b43fd08fe03f0f3c2c" name="a0c21ccdd1a1500b43fd08fe03f0f3c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c21ccdd1a1500b43fd08fe03f0f3c2c">&#9670;&#160;</a></span>split_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.split_at </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pred</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maxsplit</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>keep_separator</em><span class="paramdefsep"> = </span><span class="paramdefval">False</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield lists of items from <em>iterable</em>, where each list is delimited by an item where callable <em>pred</em> returns <code>True</code>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_at(<span class="stringliteral">&#39;abcdcba&#39;</span>, <span class="keyword">lambda</span> x: x == <span class="stringliteral">&#39;b&#39;</span>))</div>
<div class="line">[[<span class="stringliteral">&#39;a&#39;</span>], [<span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;d&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>], [<span class="stringliteral">&#39;a&#39;</span>]]</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; list(split_at(range(10), <span class="keyword">lambda</span> n: n % 2 == 1))</div>
<div class="line">[[0], [2], [4], [6], [8], []]</div>
</div><!-- fragment --><p> At most <em>maxsplit</em> splits are done. If <em>maxsplit</em> is not specified or -1, then there is no limit on the number of splits:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_at(range(10), <span class="keyword">lambda</span> n: n % 2 == 1, maxsplit=2))</div>
<div class="line">[[0], [2], [4, 5, 6, 7, 8, 9]]</div>
</div><!-- fragment --><p> By default, the delimiting items are not included in the output. The include them, set <em>keep_separator</em> to <code>True</code>.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_at(<span class="stringliteral">&#39;abcdcba&#39;</span>, <span class="keyword">lambda</span> x: x == <span class="stringliteral">&#39;b&#39;</span>, keep_separator=<span class="keyword">True</span>))</div>
<div class="line">[[<span class="stringliteral">&#39;a&#39;</span>], [<span class="stringliteral">&#39;b&#39;</span>], [<span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;d&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>], [<span class="stringliteral">&#39;b&#39;</span>], [<span class="stringliteral">&#39;a&#39;</span>]]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad7aee350818833ba18a93b952983d841" name="ad7aee350818833ba18a93b952983d841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7aee350818833ba18a93b952983d841">&#9670;&#160;</a></span>split_before()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.split_before </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pred</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maxsplit</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield lists of items from <em>iterable</em>, where each list ends just before an item for which callable <em>pred</em> returns <code>True</code>: </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_before(<span class="stringliteral">&#39;OneTwo&#39;</span>, <span class="keyword">lambda</span> s: s.isupper()))</div>
<div class="line">[[<span class="stringliteral">&#39;O&#39;</span>, <span class="stringliteral">&#39;n&#39;</span>, <span class="stringliteral">&#39;e&#39;</span>], [<span class="stringliteral">&#39;T&#39;</span>, <span class="stringliteral">&#39;w&#39;</span>, <span class="stringliteral">&#39;o&#39;</span>]]</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; list(split_before(range(10), <span class="keyword">lambda</span> n: n % 3 == 0))</div>
<div class="line">[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]</div>
</div><!-- fragment --><p> At most <em>maxsplit</em> splits are done. If <em>maxsplit</em> is not specified or -1, then there is no limit on the number of splits:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_before(range(10), <span class="keyword">lambda</span> n: n % 3 == 0, maxsplit=2))</div>
<div class="line">[[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2414703c881898f60f20d405da23acc0" name="a2414703c881898f60f20d405da23acc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2414703c881898f60f20d405da23acc0">&#9670;&#160;</a></span>split_into()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.split_into </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield a list of sequential items from <em>iterable</em> of length 'n' for each integer 'n' in <em>sizes</em>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_into([1,2,3,4,5,6], [1,2,3]))</div>
<div class="line">[[1], [2, 3], [4, 5, 6]]</div>
</div><!-- fragment --><p> If the sum of <em>sizes</em> is smaller than the length of <em>iterable</em>, then the remaining items of <em>iterable</em> will not be returned.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_into([1,2,3,4,5,6], [2,3]))</div>
<div class="line">[[1, 2], [3, 4, 5]]</div>
</div><!-- fragment --><p> If the sum of <em>sizes</em> is larger than the length of <em>iterable</em>, fewer items will be returned in the iteration that overruns <em>iterable</em> and further lists will be empty:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_into([1,2,3,4], [1,2,3,4]))</div>
<div class="line">[[1], [2, 3], [4], []]</div>
</div><!-- fragment --><p> When a <code>None</code> object is encountered in <em>sizes</em>, the returned list will contain items up to the end of <em>iterable</em> the same way that itertools.slice does:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,<span class="keywordtype">None</span>]))</div>
<div class="line">[[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]</div>
</div><!-- fragment --><p> :func:<code>split_into</code> can be useful for grouping a series of items where the sizes of the groups are not uniform. An example would be where in a row from a table, multiple columns represent elements of the same feature (e.g. a point represented by x,y,z) but, the format is not the same for all columns. </p>

</div>
</div>
<a id="a524b6352594c860dfa3b742832d114aa" name="a524b6352594c860dfa3b742832d114aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524b6352594c860dfa3b742832d114aa">&#9670;&#160;</a></span>split_when()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.split_when </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pred</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maxsplit</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split <em>iterable</em> into pieces based on the output of <em>pred</em>. </p>
<p><em>pred</em> should be a function that takes successive pairs of items and returns <code>True</code> if the iterable should be split in between them.</p>
<p>For example, to find runs of increasing numbers, split the iterable when element <code>i</code> is larger than element <code>i + 1</code>:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], <span class="keyword">lambda</span> x, y: x &gt; y))</div>
<div class="line">[[1, 2, 3, 3], [2, 5], [2, 4], [2]]</div>
</div><!-- fragment --><p> At most <em>maxsplit</em> splits are done. If <em>maxsplit</em> is not specified or -1, then there is no limit on the number of splits:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],</div>
<div class="line">...                 <span class="keyword">lambda</span> x, y: x &gt; y, maxsplit=2))</div>
<div class="line">[[1, 2, 3, 3], [2, 5], [2, 4, 2]]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad404f78ea35afd075654a37ad98a9426" name="ad404f78ea35afd075654a37ad98a9426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad404f78ea35afd075654a37ad98a9426">&#9670;&#160;</a></span>spy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.spy </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a 2-tuple with a list containing the first <em>n</em> elements of <em>iterable</em>, and an iterator with the same items as <em>iterable</em>. </p>
<p>This allows you to "look ahead" at the items in the iterable without advancing it.</p>
<p>There is one item in the list by default:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = <span class="stringliteral">&#39;abcdefg&#39;</span></div>
<div class="line">&gt;&gt;&gt; head, iterable = spy(iterable)</div>
<div class="line">&gt;&gt;&gt; head</div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>]</div>
<div class="line">&gt;&gt;&gt; list(iterable)</div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;d&#39;</span>, <span class="stringliteral">&#39;e&#39;</span>, <span class="stringliteral">&#39;f&#39;</span>, <span class="stringliteral">&#39;g&#39;</span>]</div>
</div><!-- fragment --><p> You may use unpacking to retrieve items instead of lists:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; (head,), iterable = spy(<span class="stringliteral">&#39;abcdefg&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; head</div>
<div class="line"><span class="stringliteral">&#39;a&#39;</span></div>
<div class="line">&gt;&gt;&gt; (first, second), iterable = spy(<span class="stringliteral">&#39;abcdefg&#39;</span>, 2)</div>
<div class="line">&gt;&gt;&gt; first</div>
<div class="line"><span class="stringliteral">&#39;a&#39;</span></div>
<div class="line">&gt;&gt;&gt; second</div>
<div class="line"><span class="stringliteral">&#39;b&#39;</span></div>
</div><!-- fragment --><p> The number of items requested can be larger than the number of items in the iterable:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [1, 2, 3, 4, 5]</div>
<div class="line">&gt;&gt;&gt; head, iterable = spy(iterable, 10)</div>
<div class="line">&gt;&gt;&gt; head</div>
<div class="line">[1, 2, 3, 4, 5]</div>
<div class="line">&gt;&gt;&gt; list(iterable)</div>
<div class="line">[1, 2, 3, 4, 5]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa6a5061bfeab377fdcb3819d122ea2ae" name="aa6a5061bfeab377fdcb3819d122ea2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a5061bfeab377fdcb3819d122ea2ae">&#9670;&#160;</a></span>stagger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.stagger </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>offsets</em><span class="paramdefsep"> = </span><span class="paramdefval">(-1,&#160;0,&#160;1)</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>longest</em><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fillvalue</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield tuples whose elements are offset from <em>iterable</em>. </p>
<p>The amount by which the <code>i</code>-th item in each tuple is offset is given by the <code>i</code>-th item in <em>offsets</em>.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(stagger([0, 1, 2, 3]))</div>
<div class="line">[(<span class="keywordtype">None</span>, 0, 1), (0, 1, 2), (1, 2, 3)]</div>
<div class="line">&gt;&gt;&gt; list(stagger(range(8), offsets=(0, 2, 4)))</div>
<div class="line">[(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]</div>
</div><!-- fragment --><p> By default, the sequence will end when the final element of a tuple is the last item in the iterable. To continue until the first element of a tuple is the last item in the iterable, set <em>longest</em> to <code>True</code>::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(stagger([0, 1, 2, 3], longest=<span class="keyword">True</span>))</div>
<div class="line">[(<span class="keywordtype">None</span>, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, <span class="keywordtype">None</span>), (3, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>)]</div>
</div><!-- fragment --><p> By default, <code>None</code> will be used to replace offsets beyond the end of the sequence. Specify <em>fillvalue</em> to use some other value. </p>

</div>
</div>
<a id="a4aacddd1fb6d2525e7ca741424fd0045" name="a4aacddd1fb6d2525e7ca741424fd0045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aacddd1fb6d2525e7ca741424fd0045">&#9670;&#160;</a></span>strip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.strip </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the items from <em>iterable</em>, but strip any from the beginning and end for which <em>pred</em> returns <code>True</code>. </p>
<p>For example, to remove a set of items from both ends of an iterable:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = (<span class="keywordtype">None</span>, <span class="keyword">False</span>, <span class="keywordtype">None</span>, 1, 2, <span class="keywordtype">None</span>, 3, <span class="keyword">False</span>, <span class="keywordtype">None</span>)</div>
<div class="line">&gt;&gt;&gt; pred = <span class="keyword">lambda</span> x: x <span class="keywordflow">in</span> {<span class="keywordtype">None</span>, <span class="keyword">False</span>, <span class="stringliteral">&#39;&#39;</span>}</div>
<div class="line">&gt;&gt;&gt; list(strip(iterable, pred))</div>
<div class="line">[1, 2, <span class="keywordtype">None</span>, 3]</div>
</div><!-- fragment --><p> This function is analogous to :func:<code>str.strip</code>. </p>

</div>
</div>
<a id="a0cdc9a02ebf3b5ed801ceee08af6afb5" name="a0cdc9a02ebf3b5ed801ceee08af6afb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdc9a02ebf3b5ed801ceee08af6afb5">&#9670;&#160;</a></span>substrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.substrings </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield all of the substrings of <em>iterable</em>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; [<span class="stringliteral">&#39;&#39;</span>.join(s) <span class="keywordflow">for</span> s <span class="keywordflow">in</span> substrings(<span class="stringliteral">&#39;more&#39;</span>)]</div>
<div class="line">[<span class="stringliteral">&#39;m&#39;</span>, <span class="stringliteral">&#39;o&#39;</span>, <span class="stringliteral">&#39;r&#39;</span>, <span class="stringliteral">&#39;e&#39;</span>, <span class="stringliteral">&#39;mo&#39;</span>, <span class="stringliteral">&#39;or&#39;</span>, <span class="stringliteral">&#39;re&#39;</span>, <span class="stringliteral">&#39;mor&#39;</span>, <span class="stringliteral">&#39;ore&#39;</span>, <span class="stringliteral">&#39;more&#39;</span>]</div>
</div><!-- fragment --><p> Note that non-string iterables can also be subdivided.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(substrings([0, 1, 2]))</div>
<div class="line">[(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac255ef443ff15888f55c49aa1f070ff4" name="ac255ef443ff15888f55c49aa1f070ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac255ef443ff15888f55c49aa1f070ff4">&#9670;&#160;</a></span>substrings_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.substrings_indexes </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>seq</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>reverse</em><span class="paramdefsep"> = </span><span class="paramdefval">False</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield all substrings and their positions in <em>seq</em> </p>
<p>The items yielded will be a tuple of the form <code>(substr, i, j)</code>, where <code>substr == seq[i:j]</code>.</p>
<p>This function only works for iterables that support slicing, such as <code>str</code> objects.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keywordflow">for</span> item <span class="keywordflow">in</span> substrings_indexes(<span class="stringliteral">&#39;more&#39;</span>):</div>
<div class="line">...    print(item)</div>
<div class="line">(<span class="stringliteral">&#39;m&#39;</span>, 0, 1)</div>
<div class="line">(<span class="stringliteral">&#39;o&#39;</span>, 1, 2)</div>
<div class="line">(<span class="stringliteral">&#39;r&#39;</span>, 2, 3)</div>
<div class="line">(<span class="stringliteral">&#39;e&#39;</span>, 3, 4)</div>
<div class="line">(<span class="stringliteral">&#39;mo&#39;</span>, 0, 2)</div>
<div class="line">(<span class="stringliteral">&#39;or&#39;</span>, 1, 3)</div>
<div class="line">(<span class="stringliteral">&#39;re&#39;</span>, 2, 4)</div>
<div class="line">(<span class="stringliteral">&#39;mor&#39;</span>, 0, 3)</div>
<div class="line">(<span class="stringliteral">&#39;ore&#39;</span>, 1, 4)</div>
<div class="line">(<span class="stringliteral">&#39;more&#39;</span>, 0, 4)</div>
</div><!-- fragment --><p> Set <em>reverse</em> to <code>True</code> to yield the same items in the opposite order. </p>

</div>
</div>
<a id="ad5bc505640cbe98f92a1703e472e1d00" name="ad5bc505640cbe98f92a1703e472e1d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bc505640cbe98f92a1703e472e1d00">&#9670;&#160;</a></span>unique_to_each()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.unique_to_each </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>iterables</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elements from each of the input iterables that aren't in the other input iterables. </p>
<p>For example, suppose you have a set of packages, each with a set of dependencies::</p>
<div class="fragment"><div class="line">{<span class="stringliteral">&#39;pkg_1&#39;</span>: {<span class="stringliteral">&#39;A&#39;</span>, <span class="stringliteral">&#39;B&#39;</span>}, <span class="stringliteral">&#39;pkg_2&#39;</span>: {<span class="stringliteral">&#39;B&#39;</span>, <span class="stringliteral">&#39;C&#39;</span>}, <span class="stringliteral">&#39;pkg_3&#39;</span>: {<span class="stringliteral">&#39;B&#39;</span>, <span class="stringliteral">&#39;D&#39;</span>}}</div>
</div><!-- fragment --><p> If you remove one package, which dependencies can also be removed?</p>
<p>If <code>pkg_1</code> is removed, then <code>A</code> is no longer necessary - it is not associated with <code>pkg_2</code> or <code>pkg_3</code>. Similarly, <code>C</code> is only needed for <code>pkg_2</code>, and <code>D</code> is only needed for <code>pkg_3</code>::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; unique_to_each({<span class="stringliteral">&#39;A&#39;</span>, <span class="stringliteral">&#39;B&#39;</span>}, {<span class="stringliteral">&#39;B&#39;</span>, <span class="stringliteral">&#39;C&#39;</span>}, {<span class="stringliteral">&#39;B&#39;</span>, <span class="stringliteral">&#39;D&#39;</span>})</div>
<div class="line">[[<span class="stringliteral">&#39;A&#39;</span>], [<span class="stringliteral">&#39;C&#39;</span>], [<span class="stringliteral">&#39;D&#39;</span>]]</div>
</div><!-- fragment --><p> If there are duplicates in one input iterable that aren't in the others they will be duplicated in the output. Input order is preserved::</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; unique_to_each(<span class="stringliteral">&quot;mississippi&quot;</span>, <span class="stringliteral">&quot;missouri&quot;</span>)</div>
<div class="line">[[<span class="stringliteral">&#39;p&#39;</span>, <span class="stringliteral">&#39;p&#39;</span>], [<span class="stringliteral">&#39;o&#39;</span>, <span class="stringliteral">&#39;u&#39;</span>, <span class="stringliteral">&#39;r&#39;</span>]]</div>
</div><!-- fragment --><p> It is assumed that the elements of each iterable are hashable. </p>

</div>
</div>
<a id="a32eebc9faf562f56d169cb5aec787b6d" name="a32eebc9faf562f56d169cb5aec787b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32eebc9faf562f56d169cb5aec787b6d">&#9670;&#160;</a></span>unzip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.unzip </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The inverse of :func:<code>zip</code>, this function disaggregates the elements of the zipped <em>iterable</em>. </p>
<p>The <code>i</code>-th iterable contains the <code>i</code>-th element from each element of the zipped iterable. The first element is used to to determine the length of the remaining elements.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [(<span class="stringliteral">&#39;a&#39;</span>, 1), (<span class="stringliteral">&#39;b&#39;</span>, 2), (<span class="stringliteral">&#39;c&#39;</span>, 3), (<span class="stringliteral">&#39;d&#39;</span>, 4)]</div>
<div class="line">&gt;&gt;&gt; letters, numbers = unzip(iterable)</div>
<div class="line">&gt;&gt;&gt; list(letters)</div>
<div class="line">[<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;d&#39;</span>]</div>
<div class="line">&gt;&gt;&gt; list(numbers)</div>
<div class="line">[1, 2, 3, 4]</div>
</div><!-- fragment --><p> This is similar to using <code>zip(*iterable)</code>, but it avoids reading <em>iterable</em> into memory. Note, however, that this function uses :func:<code>itertools.tee</code> and thus may require significant storage. </p>

</div>
</div>
<a id="a0b402e9e076f6d6c1d7d13dccb5d992c" name="a0b402e9e076f6d6c1d7d13dccb5d992c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b402e9e076f6d6c1d7d13dccb5d992c">&#9670;&#160;</a></span>value_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.value_chain </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield all arguments passed to the function in the same order in which they were passed. </p>
<p>If an argument itself is iterable then iterate over its values.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(value_chain(1, 2, 3, [4, 5, 6]))</div>
<div class="line">[1, 2, 3, 4, 5, 6]</div>
</div><!-- fragment --><p> Binary and text strings are not considered iterable and are emitted as-is:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(value_chain(<span class="stringliteral">&#39;12&#39;</span>, <span class="stringliteral">&#39;34&#39;</span>, [<span class="stringliteral">&#39;56&#39;</span>, <span class="stringliteral">&#39;78&#39;</span>]))</div>
<div class="line">[<span class="stringliteral">&#39;12&#39;</span>, <span class="stringliteral">&#39;34&#39;</span>, <span class="stringliteral">&#39;56&#39;</span>, <span class="stringliteral">&#39;78&#39;</span>]</div>
</div><!-- fragment --><p> Multiple levels of nesting are not flattened. </p>

</div>
</div>
<a id="a6a25a63106c08986d199ddbd78d46277" name="a6a25a63106c08986d199ddbd78d46277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a25a63106c08986d199ddbd78d46277">&#9670;&#160;</a></span>windowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.windowed </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>seq</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fillvalue</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>step</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a sliding window of width <em>n</em> over the given iterable. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; all_windows = windowed([1, 2, 3, 4, 5], 3)</div>
<div class="line">&gt;&gt;&gt; list(all_windows)</div>
<div class="line">[(1, 2, 3), (2, 3, 4), (3, 4, 5)]</div>
</div><!-- fragment --><p> When the window is larger than the iterable, <em>fillvalue</em> is used in place of missing values:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(windowed([1, 2, 3], 4))</div>
<div class="line">[(1, 2, 3, <span class="keywordtype">None</span>)]</div>
</div><!-- fragment --><p> Each window will advance in increments of <em>step</em>:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue=<span class="stringliteral">&#39;!&#39;</span>, step=2))</div>
<div class="line">[(1, 2, 3), (3, 4, 5), (5, 6, <span class="stringliteral">&#39;!&#39;</span>)]</div>
</div><!-- fragment --><p> To slide into the iterable's items, use :func:<code>chain</code> to add filler items to the left:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = [1, 2, 3, 4]</div>
<div class="line">&gt;&gt;&gt; n = 3</div>
<div class="line">&gt;&gt;&gt; padding = [<span class="keywordtype">None</span>] * (n - 1)</div>
<div class="line">&gt;&gt;&gt; list(windowed(chain(padding, iterable), 3))</div>
<div class="line">[(<span class="keywordtype">None</span>, <span class="keywordtype">None</span>, 1), (<span class="keywordtype">None</span>, 1, 2), (1, 2, 3), (2, 3, 4)]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a02c0440945239e801c6cb8025ab068c9" name="a02c0440945239e801c6cb8025ab068c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c0440945239e801c6cb8025ab068c9">&#9670;&#160;</a></span>windowed_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.windowed_complete </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iterable</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield <code>(beginning, middle, end)</code> tuples, where: </p>
<ul>
<li>Each <code>middle</code> has <em>n</em> items from <em>iterable</em></li>
<li>Each <code>beginning</code> has the items before the ones in <code>middle</code></li>
<li>Each <code>end</code> has the items after the ones in <code>middle</code></li>
</ul>
<div class="fragment"><div class="line">&gt;&gt;&gt; iterable = range(7)</div>
<div class="line">&gt;&gt;&gt; n = 3</div>
<div class="line">&gt;&gt;&gt; <span class="keywordflow">for</span> beginning, middle, end <span class="keywordflow">in</span> windowed_complete(iterable, n):</div>
<div class="line">...     print(beginning, middle, end)</div>
<div class="line">() (0, 1, 2) (3, 4, 5, 6)</div>
<div class="line">(0,) (1, 2, 3) (4, 5, 6)</div>
<div class="line">(0, 1) (2, 3, 4) (5, 6)</div>
<div class="line">(0, 1, 2) (3, 4, 5) (6,)</div>
<div class="line">(0, 1, 2, 3) (4, 5, 6) ()</div>
</div><!-- fragment --><p> Note that <em>n</em> must be at least 0 and most equal to the length of <em>iterable</em>.</p>
<p>This function will exhaust the iterable and may require significant storage. </p>

</div>
</div>
<a id="a619447baa790cfa94d6bfc301c96a573" name="a619447baa790cfa94d6bfc301c96a573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619447baa790cfa94d6bfc301c96a573">&#9670;&#160;</a></span>with_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.with_iter </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>context_manager</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap an iterable in a <code>with</code> statement, so it closes once exhausted. </p>
<p>For example, this will close the file when the iterator is exhausted::</p>
<div class="fragment"><div class="line">upper_lines = (line.upper() <span class="keywordflow">for</span> line <span class="keywordflow">in</span> with_iter(open(<span class="stringliteral">&#39;foo&#39;</span>)))</div>
</div><!-- fragment --><p> Any context manager which returns an iterable is a candidate for <code>with_iter</code>. </p>

</div>
</div>
<a id="a310cdb228065a896661fdb3af5198990" name="a310cdb228065a896661fdb3af5198990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310cdb228065a896661fdb3af5198990">&#9670;&#160;</a></span>zip_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.zip_equal </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>iterables</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>zip</code> the input <em>iterables</em> together, but raise <code>UnequalIterablesError</code> if they aren't all the same length. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; it_1 = range(3)</div>
<div class="line">&gt;&gt;&gt; it_2 = iter(<span class="stringliteral">&#39;abc&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; list(zip_equal(it_1, it_2))</div>
<div class="line">[(0, <span class="stringliteral">&#39;a&#39;</span>), (1, <span class="stringliteral">&#39;b&#39;</span>), (2, <span class="stringliteral">&#39;c&#39;</span>)]</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; it_1 = range(3)</div>
<div class="line">&gt;&gt;&gt; it_2 = iter(<span class="stringliteral">&#39;abcd&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; list(zip_equal(it_1, it_2)) <span class="comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line">Traceback (most recent call last):</div>
<div class="line">...</div>
<div class="line">more_itertools.more.UnequalIterablesError: Iterables have different</div>
<div class="line">lengths</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5b2e4bfc8d9d82c7daaa81730f316ae4" name="a5b2e4bfc8d9d82c7daaa81730f316ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2e4bfc8d9d82c7daaa81730f316ae4">&#9670;&#160;</a></span>zip_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.zip_offset </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>iterables</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>offsets</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>longest</em><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fillvalue</em><span class="paramdefsep"> = </span><span class="paramdefval">None</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>zip</code> the input <em>iterables</em> together, but offset the <code>i</code>-th iterable by the <code>i</code>-th item in <em>offsets</em>. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(zip_offset(<span class="stringliteral">&#39;0123&#39;</span>, <span class="stringliteral">&#39;abcdef&#39;</span>, offsets=(0, 1)))</div>
<div class="line">[(<span class="stringliteral">&#39;0&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>), (<span class="stringliteral">&#39;1&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>), (<span class="stringliteral">&#39;2&#39;</span>, <span class="stringliteral">&#39;d&#39;</span>), (<span class="stringliteral">&#39;3&#39;</span>, <span class="stringliteral">&#39;e&#39;</span>)]</div>
</div><!-- fragment --><p> This can be used as a lightweight alternative to SciPy or pandas to analyze data sets in which some series have a lead or lag relationship.</p>
<p>By default, the sequence will end when the shortest iterable is exhausted. To continue until the longest iterable is exhausted, set <em>longest</em> to <code>True</code>.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; list(zip_offset(<span class="stringliteral">&#39;0123&#39;</span>, <span class="stringliteral">&#39;abcdef&#39;</span>, offsets=(0, 1), longest=<span class="keyword">True</span>))</div>
<div class="line">[(<span class="stringliteral">&#39;0&#39;</span>, <span class="stringliteral">&#39;b&#39;</span>), (<span class="stringliteral">&#39;1&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>), (<span class="stringliteral">&#39;2&#39;</span>, <span class="stringliteral">&#39;d&#39;</span>), (<span class="stringliteral">&#39;3&#39;</span>, <span class="stringliteral">&#39;e&#39;</span>), (<span class="keywordtype">None</span>, <span class="stringliteral">&#39;f&#39;</span>)]</div>
</div><!-- fragment --><p> By default, <code>None</code> will be used to replace offsets beyond the end of the sequence. Specify <em>fillvalue</em> to use some other value. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac9e7235e60a759a922fdec5a1c512922" name="ac9e7235e60a759a922fdec5a1c512922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e7235e60a759a922fdec5a1c512922">&#9670;&#160;</a></span>_marker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more._marker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0031bf1f6cd4f281f6196d58cb31deb1" name="a0031bf1f6cd4f281f6196d58cb31deb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0031bf1f6cd4f281f6196d58cb31deb1">&#9670;&#160;</a></span>C</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str setuptools._vendor.more_itertools.more.C :\Users\anupamays\xDPUinfra\xDPUStorageTest\lib\host&gt;doxypypy -a -c &quot;C:/Users/anupamays/xDPUinfra/xDPUStorageTest/venv/Lib/site-packages/setuptools/_vendor/more_itertools/more.py&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
